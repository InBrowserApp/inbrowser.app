<template>
  <DescriptionMarkdown
    :title="t('what-is-bcrypt')"
    :description="t('what-is-bcrypt-description-markdown')"
  />
</template>

<script setup lang="ts">
import { DescriptionMarkdown } from '@shared/ui/base'
import { useI18n } from 'vue-i18n'

const { t } = useI18n()
</script>

<i18n lang="json">
{
  "en": {
    "what-is-bcrypt": "What is bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt is a password hashing function designed by Niels Provos and David Mazières in 1999, based on the Blowfish cipher. It's specifically designed for securely hashing passwords and is widely considered one of the best practices for password storage.\n\n**Key characteristics:**\n- **Adaptive hashing**: Uses a cost parameter (work factor) that makes it slower and more secure over time\n- **Salt integration**: Automatically generates and incorporates a random salt to prevent rainbow table attacks\n- **Time-tested security**: Over 20 years of widespread use with no known practical attacks\n- **Configurable difficulty**: The cost parameter can be adjusted to maintain security as hardware improves\n- **Cross-platform**: Available in virtually every programming language and platform\n\n**How bcrypt works:**\n🔧 **Process overview**:\n1. **Salt generation**: Creates a random 128-bit salt\n2. **Key expansion**: Uses the password and salt to expand the Blowfish key schedule\n3. **Iterative hashing**: Repeatedly applies the Blowfish encryption with the cost parameter determining iterations\n4. **Output format**: Produces a standardized string containing version, cost, salt, and hash\n\n**bcrypt hash format:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31-character hash (22 chars base64 + 9 chars)\n│ │  └─ 22-character salt (base64 encoded)\n│ └─ Cost parameter (4-31, higher = slower/more secure)\n└─ Version identifier ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Security advantages:**\n✅ **Superior password protection**:\n- **Slow by design**: Intentionally computationally expensive to thwart brute force attacks\n- **Salt prevents rainbow tables**: Each password gets a unique salt\n- **Future-proof**: Cost can be increased as hardware becomes faster\n- **Timing attack resistant**: Consistent execution time regardless of input\n- **Memory-hard**: Requires significant memory, making parallel attacks expensive\n\n**Cost parameter guidance:**\n- **Cost 10**: ~10ms (minimum recommended for 2024)\n- **Cost 12**: ~40ms (good balance for most applications)\n- **Cost 14**: ~160ms (high security applications)\n- **Cost 15+**: 300ms+ (maximum security, may impact user experience)\n\n**Common use cases:**\n- **Web applications**: User account password storage\n- **API authentication**: Securing API keys and tokens\n- **Database security**: Protecting sensitive credential data\n- **Enterprise systems**: Employee authentication systems\n- **Mobile applications**: Local password storage\n\n**Why choose bcrypt over alternatives:**\n- **Battle-tested**: Decades of real-world usage\n- **Industry standard**: Recommended by security experts and frameworks\n- **Regulatory compliance**: Meets most security compliance requirements\n- **Performance balance**: Configurable security vs. speed trade-off\n- **Wide adoption**: Supported by major frameworks (Django, Rails, Spring, etc.)\n\n**Best practices:**\n- Use cost 12 or higher for new applications\n- Regularly review and increase cost as hardware improves\n- Never store plain text passwords\n- Use bcrypt for passwords, not general-purpose hashing\n- Implement proper error handling to prevent timing attacks\n\n**Security note:**\n⚠️ **Important**: While bcrypt is excellent for passwords, it's not suitable for general-purpose cryptographic hashing. For file integrity, digital signatures, or other non-password uses, consider SHA-256, SHA-3, or other cryptographic hash functions."
  },
  "zh": {
    "what-is-bcrypt": "什么是 bcrypt？",
    "what-is-bcrypt-description-markdown": "bcrypt 是由 Niels Provos 和 David Mazières 在 1999 年设计的密码散列函数，基于 Blowfish 密码。它专门设计用于安全散列密码，被广泛认为是密码存储的最佳实践之一。\n\n**主要特征：**\n- **自适应散列**：使用成本参数（工作因子），使其随时间变得更慢、更安全\n- **盐集成**：自动生成并合并随机盐以防止彩虹表攻击\n- **经过时间考验的安全性**：超过 20 年的广泛使用，没有已知的实际攻击\n- **可配置难度**：可以调整成本参数以在硬件改进时保持安全性\n- **跨平台**：几乎在每种编程语言和平台上都可用\n\n**bcrypt 工作原理：**\n🔧 **流程概述**：\n1. **盐生成**：创建随机 128 位盐\n2. **密钥扩展**：使用密码和盐扩展 Blowfish 密钥调度\n3. **迭代散列**：重复应用 Blowfish 加密，成本参数决定迭代次数\n4. **输出格式**：产生包含版本、成本、盐和散列的标准化字符串\n\n**bcrypt 散列格式：**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31 字符散列（22 个 base64 字符 + 9 个字符）\n│ │  └─ 22 字符盐（base64 编码）\n│ └─ 成本参数（4-31，越高 = 越慢/越安全）\n└─ 版本标识符（$2a$、$2b$、$2x$、$2y$）\n```\n\n**安全优势：**\n✅ **优越的密码保护**：\n- **设计慢速**：故意计算昂贵以阻止暴力攻击\n- **盐防止彩虹表**：每个密码都有唯一的盐\n- **面向未来**：随着硬件变快可以增加成本\n- **抗时序攻击**：无论输入如何都有一致的执行时间\n- **内存困难**：需要大量内存，使并行攻击成本高昂\n\n**成本参数指导：**\n- **成本 10**：约 10ms（2024 年推荐最小值）\n- **成本 12**：约 40ms（大多数应用的良好平衡）\n- **成本 14**：约 160ms（高安全性应用）\n- **成本 15+**：300ms+（最大安全性，可能影响用户体验）\n\n**常见用例：**\n- **Web 应用**：用户账户密码存储\n- **API 认证**：保护 API 密钥和令牌\n- **数据库安全**：保护敏感凭据数据\n- **企业系统**：员工认证系统\n- **移动应用**：本地密码存储\n\n**为什么选择 bcrypt 而不是其他选择：**\n- **经过实战检验**：数十年的实际使用\n- **行业标准**：安全专家和框架推荐\n- **法规合规**：满足大多数安全合规要求\n- **性能平衡**：可配置的安全性与速度权衡\n- **广泛采用**：主要框架支持（Django、Rails、Spring 等）\n\n**最佳实践：**\n- 新应用使用成本 12 或更高\n- 随着硬件改进定期审查和增加成本\n- 永远不要存储明文密码\n- 用 bcrypt 处理密码，不用于通用散列\n- 实施适当的错误处理以防止时序攻击\n\n**安全说明：**\n⚠️ **重要**：虽然 bcrypt 对密码很好，但不适合通用加密散列。对于文件完整性、数字签名或其他非密码用途，请考虑 SHA-256、SHA-3 或其他加密散列函数。"
  },
  "zh-CN": {
    "what-is-bcrypt": "什么是 bcrypt？",
    "what-is-bcrypt-description-markdown": "bcrypt 是由 Niels Provos 和 David Mazières 在 1999 年设计的密码散列函数，基于 Blowfish 密码。它专门设计用于安全散列密码，被广泛认为是密码存储的最佳实践之一。\n\n**主要特征：**\n- **自适应散列**：使用成本参数（工作因子），使其随时间变得更慢、更安全\n- **盐集成**：自动生成并合并随机盐以防止彩虹表攻击\n- **经过时间考验的安全性**：超过 20 年的广泛使用，没有已知的实际攻击\n- **可配置难度**：可以调整成本参数以在硬件改进时保持安全性\n- **跨平台**：几乎在每种编程语言和平台上都可用\n\n**bcrypt 工作原理：**\n🔧 **流程概述**：\n1. **盐生成**：创建随机 128 位盐\n2. **密钥扩展**：使用密码和盐扩展 Blowfish 密钥调度\n3. **迭代散列**：重复应用 Blowfish 加密，成本参数决定迭代次数\n4. **输出格式**：产生包含版本、成本、盐和散列的标准化字符串\n\n**bcrypt 散列格式：**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31 字符散列（22 个 base64 字符 + 9 个字符）\n│ │  └─ 22 字符盐（base64 编码）\n│ └─ 成本参数（4-31，越高 = 越慢/越安全）\n└─ 版本标识符（$2a$、$2b$、$2x$、$2y$）\n```\n\n**安全优势：**\n✅ **优越的密码保护**：\n- **设计慢速**：故意计算昂贵以阻止暴力攻击\n- **盐防止彩虹表**：每个密码都有唯一的盐\n- **面向未来**：随着硬件变快可以增加成本\n- **抗时序攻击**：无论输入如何都有一致的执行时间\n- **内存困难**：需要大量内存，使并行攻击成本高昂\n\n**成本参数指导：**\n- **成本 10**：约 10ms（2024 年推荐最小值）\n- **成本 12**：约 40ms（大多数应用的良好平衡）\n- **成本 14**：约 160ms（高安全性应用）\n- **成本 15+**：300ms+（最大安全性，可能影响用户体验）\n\n**常见用例：**\n- **Web 应用**：用户账户密码存储\n- **API 认证**：保护 API 密钥和令牌\n- **数据库安全**：保护敏感凭据数据\n- **企业系统**：员工认证系统\n- **移动应用**：本地密码存储\n\n**为什么选择 bcrypt 而不是其他选择：**\n- **经过实战检验**：数十年的实际使用\n- **行业标准**：安全专家和框架推荐\n- **法规合规**：满足大多数安全合规要求\n- **性能平衡**：可配置的安全性与速度权衡\n- **广泛采用**：主要框架支持（Django、Rails、Spring 等）\n\n**最佳实践：**\n- 新应用使用成本 12 或更高\n- 随着硬件改进定期审查和增加成本\n- 永远不要存储明文密码\n- 用 bcrypt 处理密码，不用于通用散列\n- 实施适当的错误处理以防止时序攻击\n\n**安全说明：**\n⚠️ **重要**：虽然 bcrypt 对密码很好，但不适合通用加密散列。对于文件完整性、数字签名或其他非密码用途，请考虑 SHA-256、SHA-3 或其他加密散列函数。"
  },
  "zh-TW": {
    "what-is-bcrypt": "什麼是 bcrypt？",
    "what-is-bcrypt-description-markdown": "bcrypt 是由 Niels Provos 和 David Mazières 在 1999 年設計的密碼雜湊函數，基於 Blowfish 密碼。它專門設計用於安全雜湊密碼，被廣泛認為是密碼儲存的最佳實務之一。\n\n**主要特徵：**\n- **自適應雜湊**：使用成本參數（工作因子），使其隨時間變得更慢、更安全\n- **鹽整合**：自動產生並合併隨機鹽以防止彩虹表攻擊\n- **經過時間考驗的安全性**：超過 20 年的廣泛使用，沒有已知的實際攻擊\n- **可配置難度**：可以調整成本參數以在硬體改進時保持安全性\n- **跨平台**：幾乎在每種程式語言和平台上都可用\n\n**bcrypt 工作原理：**\n🔧 **流程概述**：\n1. **鹽產生**：建立隨機 128 位元鹽\n2. **金鑰擴展**：使用密碼和鹽擴展 Blowfish 金鑰調度\n3. **迭代雜湊**：重複應用 Blowfish 加密，成本參數決定迭代次數\n4. **輸出格式**：產生包含版本、成本、鹽和雜湊的標準化字串\n\n**bcrypt 雜湊格式：**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31 字元雜湊（22 個 base64 字元 + 9 個字元）\n│ │  └─ 22 字元鹽（base64 編碼）\n│ └─ 成本參數（4-31，越高 = 越慢/越安全）\n└─ 版本識別符（$2a$、$2b$、$2x$、$2y$）\n```\n\n**安全優勢：**\n✅ **優越的密碼保護**：\n- **設計慢速**：故意計算昂貴以阻止暴力攻擊\n- **鹽防止彩虹表**：每個密碼都有唯一的鹽\n- **面向未來**：隨著硬體變快可以增加成本\n- **抗時序攻擊**：無論輸入如何都有一致的執行時間\n- **記憶體困難**：需要大量記憶體，使並行攻擊成本高昂\n\n**成本參數指導：**\n- **成本 10**：約 10ms（2024 年推薦最小值）\n- **成本 12**：約 40ms（大多數應用的良好平衡）\n- **成本 14**：約 160ms（高安全性應用）\n- **成本 15+**：300ms+（最大安全性，可能影響使用者體驗）\n\n**常見用例：**\n- **Web 應用**：使用者帳戶密碼儲存\n- **API 認證**：保護 API 金鑰和權杖\n- **資料庫安全**：保護敏感憑據資料\n- **企業系統**：員工認證系統\n- **行動應用**：本地密碼儲存\n\n**為什麼選擇 bcrypt 而不是其他選擇：**\n- **經過實戰檢驗**：數十年的實際使用\n- **行業標準**：安全專家和框架推薦\n- **法規合規**：滿足大多數安全合規要求\n- **效能平衡**：可配置的安全性與速度權衡\n- **廣泛採用**：主要框架支援（Django、Rails、Spring 等）\n\n**最佳實務：**\n- 新應用使用成本 12 或更高\n- 隨著硬體改進定期審查和增加成本\n- 永遠不要儲存明文密碼\n- 用 bcrypt 處理密碼，不用於通用雜湊\n- 實施適當的錯誤處理以防止時序攻擊\n\n**安全說明：**\n⚠️ **重要**：雖然 bcrypt 對密碼很好，但不適合通用加密雜湊。對於檔案完整性、數位簽章或其他非密碼用途，請考慮 SHA-256、SHA-3 或其他加密雜湊函數。"
  },
  "zh-HK": {
    "what-is-bcrypt": "什麼是 bcrypt？",
    "what-is-bcrypt-description-markdown": "bcrypt 是由 Niels Provos 和 David Mazières 在 1999 年設計的密碼雜湊函數，基於 Blowfish 密碼。它專門設計用於安全雜湊密碼，被廣泛認為是密碼儲存的最佳實務之一。\n\n**主要特徵：**\n- **自適應雜湊**：使用成本參數（工作因子），使其隨時間變得更慢、更安全\n- **鹽整合**：自動產生並合併隨機鹽以防止彩虹表攻擊\n- **經過時間考驗的安全性**：超過 20 年的廣泛使用，沒有已知的實際攻擊\n- **可配置難度**：可以調整成本參數以在硬體改進時保持安全性\n- **跨平台**：幾乎在每種程式語言和平台上都可用\n\n**bcrypt 工作原理：**\n🔧 **流程概述**：\n1. **鹽產生**：建立隨機 128 位元鹽\n2. **金鑰擴展**：使用密碼和鹽擴展 Blowfish 金鑰調度\n3. **迭代雜湊**：重複應用 Blowfish 加密，成本參數決定迭代次數\n4. **輸出格式**：產生包含版本、成本、鹽和雜湊的標準化字串\n\n**bcrypt 雜湊格式：**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31 字元雜湊（22 個 base64 字元 + 9 個字元）\n│ │  └─ 22 字元鹽（base64 編碼）\n│ └─ 成本參數（4-31，越高 = 越慢/越安全）\n└─ 版本識別符（$2a$、$2b$、$2x$、$2y$）\n```\n\n**安全優勢：**\n✅ **優越的密碼保護**：\n- **設計慢速**：故意計算昂貴以阻止暴力攻擊\n- **鹽防止彩虹表**：每個密碼都有唯一的鹽\n- **面向未來**：隨著硬體變快可以增加成本\n- **抗時序攻擊**：無論輸入如何都有一致的執行時間\n- **記憶體困難**：需要大量記憶體，使並行攻擊成本高昂\n\n**成本參數指導：**\n- **成本 10**：約 10ms（2024 年推薦最小值）\n- **成本 12**：約 40ms（大多數應用的良好平衡）\n- **成本 14**：約 160ms（高安全性應用）\n- **成本 15+**：300ms+（最大安全性，可能影響使用者體驗）\n\n**常見用例：**\n- **Web 應用**：使用者帳戶密碼儲存\n- **API 認證**：保護 API 金鑰和權杖\n- **資料庫安全**：保護敏感憑據資料\n- **企業系統**：員工認證系統\n- **行動應用**：本地密碼儲存\n\n**為什麼選擇 bcrypt 而不是其他選擇：**\n- **經過實戰檢驗**：數十年的實際使用\n- **行業標準**：安全專家和框架推薦\n- **法規合規**：滿足大多數安全合規要求\n- **效能平衡**：可配置的安全性與速度權衡\n- **廣泛採用**：主要框架支援（Django、Rails、Spring 等）\n\n**最佳實務：**\n- 新應用使用成本 12 或更高\n- 隨著硬體改進定期審查和增加成本\n- 永遠不要儲存明文密碼\n- 用 bcrypt 處理密碼，不用於通用雜湊\n- 實施適當的錯誤處理以防止時序攻擊\n\n**安全說明：**\n⚠️ **重要**：雖然 bcrypt 對密碼很好，但不適合通用加密雜湊。對於檔案完整性、數位簽章或其他非密碼用途，請考慮 SHA-256、SHA-3 或其他加密雜湊函數。"
  },
  "es": {
    "what-is-bcrypt": "¿Qué es bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt es una función de hash de contraseñas diseñada por Niels Provos y David Mazières en 1999, basada en el cifrado Blowfish. Está específicamente diseñada para hacer hash de contraseñas de forma segura y es ampliamente considerada una de las mejores prácticas para el almacenamiento de contraseñas.\n\n**Características clave:**\n- **Hash adaptativo**: Usa un parámetro de costo (factor de trabajo) que lo hace más lento y seguro con el tiempo\n- **Integración de sal**: Genera automáticamente e incorpora una sal aleatoria para prevenir ataques de tablas arcoíris\n- **Seguridad probada en el tiempo**: Más de 20 años de uso generalizado sin ataques prácticos conocidos\n- **Dificultad configurable**: El parámetro de costo puede ajustarse para mantener la seguridad a medida que mejora el hardware\n- **Multiplataforma**: Disponible en prácticamente todos los lenguajes de programación y plataformas\n\n**Cómo funciona bcrypt:**\n🔧 **Resumen del proceso**:\n1. **Generación de sal**: Crea una sal aleatoria de 128 bits\n2. **Expansión de clave**: Usa la contraseña y la sal para expandir el programa de claves Blowfish\n3. **Hash iterativo**: Aplica repetidamente el cifrado Blowfish con el parámetro de costo determinando las iteraciones\n4. **Formato de salida**: Produce una cadena estandarizada que contiene versión, costo, sal y hash\n\n**Formato de hash bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ Hash de 31 caracteres (22 chars base64 + 9 chars)\n│ │  └─ Sal de 22 caracteres (codificada en base64)\n│ └─ Parámetro de costo (4-31, mayor = más lento/más seguro)\n└─ Identificador de versión ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Ventajas de seguridad:**\n✅ **Protección superior de contraseñas**:\n- **Lento por diseño**: Intencionalmente costoso computacionalmente para frustrar ataques de fuerza bruta\n- **La sal previene tablas arcoíris**: Cada contraseña obtiene una sal única\n- **A prueba de futuro**: El costo puede aumentarse a medida que el hardware se vuelve más rápido\n- **Resistente a ataques de tiempo**: Tiempo de ejecución consistente independientemente de la entrada\n- **Difícil en memoria**: Requiere memoria significativa, haciendo costosos los ataques paralelos\n\n**Guía de parámetros de costo:**\n- **Costo 10**: ~10ms (mínimo recomendado para 2024)\n- **Costo 12**: ~40ms (buen equilibrio para la mayoría de aplicaciones)\n- **Costo 14**: ~160ms (aplicaciones de alta seguridad)\n- **Costo 15+**: 300ms+ (máxima seguridad, puede impactar la experiencia del usuario)\n\n**Casos de uso comunes:**\n- **Aplicaciones web**: Almacenamiento de contraseñas de cuentas de usuario\n- **Autenticación API**: Protección de claves API y tokens\n- **Seguridad de base de datos**: Protección de datos de credenciales sensibles\n- **Sistemas empresariales**: Sistemas de autenticación de empleados\n- **Aplicaciones móviles**: Almacenamiento local de contraseñas\n\n**Por qué elegir bcrypt sobre alternativas:**\n- **Probado en batalla**: Décadas de uso en el mundo real\n- **Estándar de la industria**: Recomendado por expertos en seguridad y frameworks\n- **Cumplimiento regulatorio**: Cumple la mayoría de requisitos de cumplimiento de seguridad\n- **Equilibrio de rendimiento**: Intercambio configurable entre seguridad y velocidad\n- **Adopción amplia**: Soportado por frameworks principales (Django, Rails, Spring, etc.)\n\n**Mejores prácticas:**\n- Usar costo 12 o mayor para nuevas aplicaciones\n- Revisar regularmente y aumentar el costo a medida que mejora el hardware\n- Nunca almacenar contraseñas en texto plano\n- Usar bcrypt para contraseñas, no para hash de propósito general\n- Implementar manejo de errores adecuado para prevenir ataques de tiempo\n\n**Nota de seguridad:**\n⚠️ **Importante**: Aunque bcrypt es excelente para contraseñas, no es adecuado para hash criptográfico de propósito general. Para integridad de archivos, firmas digitales u otros usos no relacionados con contraseñas, considera SHA-256, SHA-3 u otras funciones hash criptográficas."
  },
  "fr": {
    "what-is-bcrypt": "Qu'est-ce que bcrypt ?",
    "what-is-bcrypt-description-markdown": "bcrypt est une fonction de hachage de mots de passe conçue par Niels Provos et David Mazières en 1999, basée sur le chiffrement Blowfish. Elle est spécifiquement conçue pour hacher les mots de passe de manière sécurisée et est largement considérée comme l'une des meilleures pratiques pour le stockage de mots de passe.\n\n**Caractéristiques clés :**\n- **Hachage adaptatif** : Utilise un paramètre de coût (facteur de travail) qui le rend plus lent et plus sécurisé au fil du temps\n- **Intégration de sel** : Génère automatiquement et incorpore un sel aléatoire pour prévenir les attaques par tables arc-en-ciel\n- **Sécurité éprouvée** : Plus de 20 ans d'utilisation généralisée sans attaques pratiques connues\n- **Difficulté configurable** : Le paramètre de coût peut être ajusté pour maintenir la sécurité à mesure que le matériel s'améliore\n- **Multi-plateforme** : Disponible dans pratiquement tous les langages de programmation et plateformes\n\n**Comment fonctionne bcrypt :**\n🔧 **Aperçu du processus** :\n1. **Génération de sel** : Crée un sel aléatoire de 128 bits\n2. **Expansion de clé** : Utilise le mot de passe et le sel pour étendre l'ordonnancement de clés Blowfish\n3. **Hachage itératif** : Applique répétitivement le chiffrement Blowfish avec le paramètre de coût déterminant les itérations\n4. **Format de sortie** : Produit une chaîne standardisée contenant version, coût, sel et hachage\n\n**Format de hachage bcrypt :**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ Hachage de 31 caractères (22 chars base64 + 9 chars)\n│ │  └─ Sel de 22 caractères (encodé en base64)\n│ └─ Paramètre de coût (4-31, plus élevé = plus lent/plus sécurisé)\n└─ Identifiant de version ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Avantages sécuritaires :**\n✅ **Protection supérieure des mots de passe** :\n- **Lent par conception** : Intentionnellement coûteux en calcul pour contrecarrer les attaques par force brute\n- **Le sel prévient les tables arc-en-ciel** : Chaque mot de passe obtient un sel unique\n- **Résistant au futur** : Le coût peut être augmenté à mesure que le matériel devient plus rapide\n- **Résistant aux attaques temporelles** : Temps d'exécution cohérent indépendamment de l'entrée\n- **Difficile en mémoire** : Nécessite une mémoire significative, rendant les attaques parallèles coûteuses\n\n**Guide des paramètres de coût :**\n- **Coût 10** : ~10ms (minimum recommandé pour 2024)\n- **Coût 12** : ~40ms (bon équilibre pour la plupart des applications)\n- **Coût 14** : ~160ms (applications haute sécurité)\n- **Coût 15+** : 300ms+ (sécurité maximale, peut impacter l'expérience utilisateur)\n\n**Cas d'usage courants :**\n- **Applications web** : Stockage de mots de passe de comptes utilisateur\n- **Authentification API** : Sécurisation des clés API et tokens\n- **Sécurité base de données** : Protection des données d'identification sensibles\n- **Systèmes d'entreprise** : Systèmes d'authentification des employés\n- **Applications mobiles** : Stockage local de mots de passe\n\n**Pourquoi choisir bcrypt plutôt que les alternatives :**\n- **Éprouvé au combat** : Décennies d'utilisation en conditions réelles\n- **Standard de l'industrie** : Recommandé par les experts en sécurité et les frameworks\n- **Conformité réglementaire** : Répond à la plupart des exigences de conformité sécuritaire\n- **Équilibre performance** : Compromis configurable sécurité vs vitesse\n- **Adoption large** : Supporté par les frameworks majeurs (Django, Rails, Spring, etc.)\n\n**Meilleures pratiques :**\n- Utiliser un coût 12 ou plus pour les nouvelles applications\n- Réviser régulièrement et augmenter le coût à mesure que le matériel s'améliore\n- Ne jamais stocker les mots de passe en texte clair\n- Utiliser bcrypt pour les mots de passe, pas pour le hachage général\n- Implémenter une gestion d'erreur appropriée pour prévenir les attaques temporelles\n\n**Note de sécurité :**\n⚠️ **Important** : Bien que bcrypt soit excellent pour les mots de passe, il n'est pas adapté au hachage cryptographique général. Pour l'intégrité de fichiers, les signatures numériques ou autres usages non-mots de passe, considérez SHA-256, SHA-3 ou autres fonctions de hachage cryptographiques."
  },
  "de": {
    "what-is-bcrypt": "Was ist bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt ist eine Passwort-Hash-Funktion, die von Niels Provos und David Mazières 1999 entwickelt wurde und auf der Blowfish-Verschlüsselung basiert. Sie ist speziell für das sichere Hashen von Passwörtern entwickelt und gilt weithin als eine der besten Praktiken für die Passwort-Speicherung.\n\n**Hauptmerkmale:**\n- **Adaptives Hashing**: Verwendet einen Kostenparameter (Arbeitsfaktor), der es mit der Zeit langsamer und sicherer macht\n- **Salt-Integration**: Generiert automatisch ein zufälliges Salt und integriert es, um Rainbow-Table-Angriffe zu verhindern\n- **Zeiterprobte Sicherheit**: Über 20 Jahre weit verbreiteter Nutzung ohne bekannte praktische Angriffe\n- **Konfigurierbare Schwierigkeit**: Der Kostenparameter kann angepasst werden, um die Sicherheit bei verbesserter Hardware aufrechtzuerhalten\n- **Plattformübergreifend**: Verfügbar in praktisch jeder Programmiersprache und Plattform\n\n**Wie bcrypt funktioniert:**\n🔧 **Prozess-Überblick**:\n1. **Salt-Generierung**: Erstellt ein zufälliges 128-Bit-Salt\n2. **Schlüssel-Erweiterung**: Verwendet Passwort und Salt zur Erweiterung des Blowfish-Schlüsselplans\n3. **Iteratives Hashing**: Wendet wiederholt Blowfish-Verschlüsselung an, wobei der Kostenparameter die Iterationen bestimmt\n4. **Ausgabeformat**: Produziert eine standardisierte Zeichenkette mit Version, Kosten, Salt und Hash\n\n**bcrypt Hash-Format:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31-Zeichen-Hash (22 Zeichen base64 + 9 Zeichen)\n│ │  └─ 22-Zeichen-Salt (base64-kodiert)\n│ └─ Kostenparameter (4-31, höher = langsamer/sicherer)\n└─ Versions-Identifikator ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Sicherheitsvorteile:**\n✅ **Überlegener Passwort-Schutz**:\n- **Designbedingt langsam**: Absichtlich rechenaufwändig, um Brute-Force-Angriffe zu vereiteln\n- **Salt verhindert Rainbow-Tables**: Jedes Passwort erhält ein einzigartiges Salt\n- **Zukunftssicher**: Kosten können erhöht werden, wenn Hardware schneller wird\n- **Timing-Angriff-resistent**: Konsistente Ausführungszeit unabhängig von der Eingabe\n- **Speicher-schwer**: Benötigt erheblichen Speicher, macht parallele Angriffe teuer\n\n**Kostenparameter-Leitfaden:**\n- **Kosten 10**: ~10ms (empfohlenes Minimum für 2024)\n- **Kosten 12**: ~40ms (gute Balance für die meisten Anwendungen)\n- **Kosten 14**: ~160ms (Hochsicherheitsanwendungen)\n- **Kosten 15+**: 300ms+ (maximale Sicherheit, kann Benutzererfahrung beeinträchtigen)\n\n**Häufige Anwendungsfälle:**\n- **Webanwendungen**: Benutzerkonten-Passwort-Speicherung\n- **API-Authentifizierung**: Schutz von API-Schlüsseln und Tokens\n- **Datenbank-Sicherheit**: Schutz sensibler Anmeldedaten\n- **Unternehmenssysteme**: Mitarbeiter-Authentifizierungssysteme\n- **Mobile Anwendungen**: Lokale Passwort-Speicherung\n\n**Warum bcrypt statt Alternativen wählen:**\n- **Kampferprobt**: Jahrzehnte realer Nutzung\n- **Industriestandard**: Von Sicherheitsexperten und Frameworks empfohlen\n- **Regulatorische Konformität**: Erfüllt die meisten Sicherheits-Compliance-Anforderungen\n- **Performance-Balance**: Konfigurierbarer Sicherheit-vs-Geschwindigkeit-Kompromiss\n- **Breite Akzeptanz**: Unterstützt von großen Frameworks (Django, Rails, Spring, etc.)\n\n**Best Practices:**\n- Kosten 12 oder höher für neue Anwendungen verwenden\n- Regelmäßig überprüfen und Kosten erhöhen, wenn Hardware sich verbessert\n- Niemals Klartext-Passwörter speichern\n- bcrypt für Passwörter verwenden, nicht für allgemeines Hashing\n- Angemessene Fehlerbehandlung implementieren, um Timing-Angriffe zu verhindern\n\n**Sicherheitshinweis:**\n⚠️ **Wichtig**: Obwohl bcrypt für Passwörter ausgezeichnet ist, ist es nicht für allgemeine kryptographische Hashes geeignet. Für Datei-Integrität, digitale Signaturen oder andere Nicht-Passwort-Verwendungen sollten SHA-256, SHA-3 oder andere kryptographische Hash-Funktionen in Betracht gezogen werden."
  },
  "it": {
    "what-is-bcrypt": "Cos'è bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt è una funzione di hash per password progettata da Niels Provos e David Mazières nel 1999, basata sul cifrario Blowfish. È specificamente progettata per l'hashing sicuro delle password ed è ampiamente considerata una delle migliori pratiche per l'archiviazione delle password.\n\n**Caratteristiche chiave:**\n- **Hashing adattivo**: Usa un parametro di costo (fattore di lavoro) che lo rende più lento e sicuro nel tempo\n- **Integrazione salt**: Genera automaticamente e incorpora un salt casuale per prevenire attacchi rainbow table\n- **Sicurezza testata nel tempo**: Oltre 20 anni di uso diffuso senza attacchi pratici conosciuti\n- **Difficoltà configurabile**: Il parametro di costo può essere regolato per mantenere la sicurezza man mano che l'hardware migliora\n- **Cross-platform**: Disponibile in praticamente ogni linguaggio di programmazione e piattaforma\n\n**Come funziona bcrypt:**\n🔧 **Panoramica del processo**:\n1. **Generazione salt**: Crea un salt casuale a 128 bit\n2. **Espansione chiave**: Usa password e salt per espandere lo schedule delle chiavi Blowfish\n3. **Hashing iterativo**: Applica ripetutamente la crittografia Blowfish con il parametro di costo che determina le iterazioni\n4. **Formato output**: Produce una stringa standardizzata contenente versione, costo, salt e hash\n\n**Formato hash bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ Hash a 31 caratteri (22 char base64 + 9 char)\n│ │  └─ Salt a 22 caratteri (codificato base64)\n│ └─ Parametro di costo (4-31, più alto = più lento/più sicuro)\n└─ Identificatore versione ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Vantaggi di sicurezza:**\n✅ **Protezione password superiore**:\n- **Lento per design**: Intenzionalmente computazionalmente costoso per frustrare attacchi brute force\n- **Il salt previene rainbow table**: Ogni password ottiene un salt unico\n- **A prova di futuro**: Il costo può essere aumentato man mano che l'hardware diventa più veloce\n- **Resistente ad attacchi timing**: Tempo di esecuzione consistente indipendentemente dall'input\n- **Memory-hard**: Richiede memoria significativa, rendendo costosi gli attacchi paralleli\n\n**Guida parametri di costo:**\n- **Costo 10**: ~10ms (minimo raccomandato per 2024)\n- **Costo 12**: ~40ms (buon equilibrio per la maggior parte delle applicazioni)\n- **Costo 14**: ~160ms (applicazioni ad alta sicurezza)\n- **Costo 15+**: 300ms+ (sicurezza massima, può impattare l'esperienza utente)\n\n**Casi d'uso comuni:**\n- **Applicazioni web**: Archiviazione password account utente\n- **Autenticazione API**: Protezione chiavi API e token\n- **Sicurezza database**: Protezione dati credenziali sensibili\n- **Sistemi aziendali**: Sistemi autenticazione dipendenti\n- **Applicazioni mobile**: Archiviazione password locale\n\n**Perché scegliere bcrypt rispetto alle alternative:**\n- **Testato in battaglia**: Decenni di uso nel mondo reale\n- **Standard industriale**: Raccomandato da esperti di sicurezza e framework\n- **Conformità normativa**: Soddisfa la maggior parte dei requisiti di conformità sicurezza\n- **Equilibrio prestazioni**: Compromesso configurabile sicurezza vs velocità\n- **Adozione ampia**: Supportato dai principali framework (Django, Rails, Spring, ecc.)\n\n**Migliori pratiche:**\n- Usare costo 12 o superiore per nuove applicazioni\n- Rivedere regolarmente e aumentare il costo man mano che l'hardware migliora\n- Non archiviare mai password in testo semplice\n- Usare bcrypt per password, non per hashing generale\n- Implementare gestione errori appropriata per prevenire attacchi timing\n\n**Nota di sicurezza:**\n⚠️ **Importante**: Sebbene bcrypt sia eccellente per le password, non è adatto per hashing crittografico generico. Per integrità file, firme digitali o altri usi non-password, considera SHA-256, SHA-3 o altre funzioni hash crittografiche."
  },
  "ja": {
    "what-is-bcrypt": "bcryptとは？",
    "what-is-bcrypt-description-markdown": "bcryptは、1999年にNiels ProvosとDavid Mazièresによって設計されたパスワードハッシュ関数で、Blowfish暗号に基づいています。パスワードを安全にハッシュ化するために特別に設計されており、パスワード保存のベストプラクティスの一つとして広く認められています。\n\n**主な特徴：**\n- **適応的ハッシュ化**：時間の経過とともに遅く、より安全になるコストパラメータ（作業係数）を使用\n- **ソルト統合**：レインボーテーブル攻撃を防ぐためにランダムソルトを自動生成・組み込み\n- **時間で証明された安全性**：20年以上の広範囲な使用で実用的な攻撃は知られていない\n- **設定可能な難易度**：ハードウェアの改善に合わせてセキュリティを維持するためにコストパラメータを調整可能\n- **クロスプラットフォーム**：ほぼすべてのプログラミング言語とプラットフォームで利用可能\n\n**bcryptの動作原理：**\n🔧 **プロセス概要**：\n1. **ソルト生成**：ランダムな128ビットソルトを作成\n2. **キー拡張**：パスワードとソルトを使用してBlowfishキースケジュールを拡張\n3. **反復ハッシュ化**：コストパラメータが反復回数を決定してBlowfish暗号化を繰り返し適用\n4. **出力形式**：バージョン、コスト、ソルト、ハッシュを含む標準化された文字列を生成\n\n**bcryptハッシュ形式：**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31文字ハッシュ（22文字base64 + 9文字）\n│ │  └─ 22文字ソルト（base64エンコード）\n│ └─ コストパラメータ（4-31、高い = 遅い/より安全）\n└─ バージョン識別子（$2a$、$2b$、$2x$、$2y$）\n```\n\n**セキュリティ利点：**\n✅ **優れたパスワード保護**：\n- **設計上の遅さ**：ブルートフォース攻撃を阻むために意図的に計算コストが高い\n- **ソルトがレインボーテーブルを防ぐ**：各パスワードが一意のソルトを取得\n- **将来対応**：ハードウェアの高速化に合わせてコストを増加可能\n- **タイミング攻撃耐性**：入力に関係なく一貫した実行時間\n- **メモリハード**：大量のメモリが必要で並列攻撃を高コストにする\n\n**コストパラメータガイド：**\n- **コスト10**：約10ms（2024年推奨最小値）\n- **コスト12**：約40ms（ほとんどのアプリケーションに良いバランス）\n- **コスト14**：約160ms（高セキュリティアプリケーション）\n- **コスト15+**：300ms+（最大セキュリティ、ユーザー体験に影響の可能性）\n\n**一般的な使用例：**\n- **Webアプリケーション**：ユーザーアカウントパスワード保存\n- **API認証**：APIキーとトークンの保護\n- **データベースセキュリティ**：機密認証情報データの保護\n- **企業システム**：従業員認証システム\n- **モバイルアプリケーション**：ローカルパスワード保存\n\n**代替案よりbcryptを選ぶ理由：**\n- **実戦で証明済み**：数十年の実世界での使用\n- **業界標準**：セキュリティ専門家とフレームワークが推奨\n- **規制遵守**：ほとんどのセキュリティコンプライアンス要件を満たす\n- **パフォーマンスバランス**：設定可能なセキュリティ対速度のトレードオフ\n- **広範囲な採用**：主要フレームワーク（Django、Rails、Spring等）でサポート\n\n**ベストプラクティス：**\n- 新しいアプリケーションではコスト12以上を使用\n- ハードウェアの改善に合わせて定期的にレビューし、コストを増加\n- 平文パスワードを保存しない\n- パスワードにbcryptを使用し、汎用ハッシュには使わない\n- タイミング攻撃を防ぐために適切なエラーハンドリングを実装\n\n**セキュリティ注意点：**\n⚠️ **重要**：bcryptはパスワードには優秀ですが、汎用暗号ハッシュには適していません。ファイル整合性、デジタル署名、その他の非パスワード用途には、SHA-256、SHA-3、その他の暗号ハッシュ関数を検討してください。"
  },
  "ko": {
    "what-is-bcrypt": "bcrypt란?",
    "what-is-bcrypt-description-markdown": "bcrypt는 1999년 Niels Provos와 David Mazières가 설계한 패스워드 해시 함수로, Blowfish 암호에 기반합니다. 패스워드를 안전하게 해시하기 위해 특별히 설계되었으며, 패스워드 저장의 모범 사례 중 하나로 널리 인정받고 있습니다.\n\n**주요 특징:**\n- **적응형 해싱**: 시간이 지남에 따라 더 느리고 안전해지도록 하는 비용 매개변수(작업 인수)를 사용\n- **솔트 통합**: 레인보우 테이블 공격을 방지하기 위해 무작위 솔트를 자동 생성하고 통합\n- **시간으로 입증된 보안**: 20년 이상의 광범위한 사용으로 실용적인 공격이 알려지지 않음\n- **구성 가능한 난이도**: 하드웨어가 개선됨에 따라 보안을 유지하기 위해 비용 매개변수를 조정 가능\n- **크로스 플랫폼**: 거의 모든 프로그래밍 언어와 플랫폼에서 사용 가능\n\n**bcrypt 작동 원리:**\n🔧 **프로세스 개요**:\n1. **솔트 생성**: 무작위 128비트 솔트 생성\n2. **키 확장**: 패스워드와 솔트를 사용하여 Blowfish 키 스케줄 확장\n3. **반복 해싱**: 비용 매개변수가 반복 횟수를 결정하여 Blowfish 암호화를 반복 적용\n4. **출력 형식**: 버전, 비용, 솔트, 해시를 포함하는 표준화된 문자열 생성\n\n**bcrypt 해시 형식:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31자 해시 (22자 base64 + 9자)\n│ │  └─ 22자 솔트 (base64 인코딩)\n│ └─ 비용 매개변수 (4-31, 높을수록 = 느림/더 안전)\n└─ 버전 식별자 ($2a$, $2b$, $2x$, $2y$)\n```\n\n**보안 장점:**\n✅ **우수한 패스워드 보호**:\n- **의도적 느림**: 브루트 포스 공격을 좌절시키기 위해 의도적으로 계산 비용이 높음\n- **솔트가 레인보우 테이블 방지**: 각 패스워드가 고유한 솔트를 얻음\n- **미래 대응**: 하드웨어가 빨라짐에 따라 비용을 증가시킬 수 있음\n- **타이밍 공격 저항**: 입력에 관계없이 일관된 실행 시간\n- **메모리 하드**: 상당한 메모리가 필요하여 병렬 공격을 비용이 많이 들게 함\n\n**비용 매개변수 가이드:**\n- **비용 10**: ~10ms (2024년 권장 최소값)\n- **비용 12**: ~40ms (대부분 애플리케이션에 좋은 균형)\n- **비용 14**: ~160ms (고보안 애플리케이션)\n- **비용 15+**: 300ms+ (최대 보안, 사용자 경험에 영향 가능)\n\n**일반적인 사용 사례:**\n- **웹 애플리케이션**: 사용자 계정 패스워드 저장\n- **API 인증**: API 키와 토큰 보호\n- **데이터베이스 보안**: 민감한 자격 증명 데이터 보호\n- **기업 시스템**: 직원 인증 시스템\n- **모바일 애플리케이션**: 로컬 패스워드 저장\n\n**대안보다 bcrypt를 선택하는 이유:**\n- **실전 검증**: 수십 년의 실제 사용\n- **업계 표준**: 보안 전문가와 프레임워크가 권장\n- **규정 준수**: 대부분의 보안 준수 요구사항 충족\n- **성능 균형**: 구성 가능한 보안 대 속도 트레이드오프\n- **광범위한 채택**: 주요 프레임워크(Django, Rails, Spring 등)에서 지원\n\n**모범 사례:**\n- 새 애플리케이션에 비용 12 이상 사용\n- 하드웨어 개선에 따라 정기적으로 검토하고 비용 증가\n- 평문 패스워드를 절대 저장하지 않음\n- 패스워드에 bcrypt 사용, 범용 해싱에는 사용하지 않음\n- 타이밍 공격을 방지하기 위한 적절한 오류 처리 구현\n\n**보안 참고사항:**\n⚠️ **중요**: bcrypt는 패스워드에는 우수하지만 범용 암호화 해싱에는 적합하지 않습니다. 파일 무결성, 디지털 서명 또는 기타 비패스워드 용도에는 SHA-256, SHA-3 또는 기타 암호화 해시 함수를 고려하세요."
  },
  "ru": {
    "what-is-bcrypt": "Что такое bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt — это функция хеширования паролей, разработанная Нильсом Провосом и Дэвидом Мазьером в 1999 году на основе шифра Blowfish. Она специально разработана для безопасного хеширования паролей и широко считается одной из лучших практик для хранения паролей.\n\n**Ключевые характеристики:**\n- **Адаптивное хеширование**: Использует параметр стоимости (рабочий фактор), который делает его медленнее и безопаснее со временем\n- **Интеграция соли**: Автоматически генерирует и включает случайную соль для предотвращения атак радужных таблиц\n- **Временно проверенная безопасность**: Более 20 лет широкого использования без известных практических атак\n- **Настраиваемая сложность**: Параметр стоимости может быть отрегулирован для поддержания безопасности по мере улучшения оборудования\n- **Кроссплатформенность**: Доступен практически в каждом языке программирования и платформе\n\n**Как работает bcrypt:**\n🔧 **Обзор процесса**:\n1. **Генерация соли**: Создает случайную 128-битную соль\n2. **Расширение ключа**: Использует пароль и соль для расширения расписания ключей Blowfish\n3. **Итеративное хеширование**: Многократно применяет шифрование Blowfish с параметром стоимости, определяющим итерации\n4. **Формат вывода**: Производит стандартизированную строку, содержащую версию, стоимость, соль и хеш\n\n**Формат хеша bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31-символьный хеш (22 символа base64 + 9 символов)\n│ │  └─ 22-символьная соль (кодировка base64)\n│ └─ Параметр стоимости (4-31, выше = медленнее/безопаснее)\n└─ Идентификатор версии ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Преимущества безопасности:**\n✅ **Превосходная защита паролей**:\n- **Медленность по дизайну**: Намеренно вычислительно дорогой для предотвращения атак грубой силы\n- **Соль предотвращает радужные таблицы**: Каждый пароль получает уникальную соль\n- **Устойчивость к будущему**: Стоимость может быть увеличена по мере ускорения оборудования\n- **Устойчивость к атакам по времени**: Постоянное время выполнения независимо от входных данных\n- **Сложность памяти**: Требует значительную память, делая параллельные атаки дорогими\n\n**Руководство по параметрам стоимости:**\n- **Стоимость 10**: ~10мс (рекомендуемый минимум для 2024)\n- **Стоимость 12**: ~40мс (хороший баланс для большинства приложений)\n- **Стоимость 14**: ~160мс (приложения высокой безопасности)\n- **Стоимость 15+**: 300мс+ (максимальная безопасность, может повлиять на пользовательский опыт)\n\n**Обычные случаи использования:**\n- **Веб-приложения**: Хранение паролей учетных записей пользователей\n- **API-аутентификация**: Защита API-ключей и токенов\n- **Безопасность баз данных**: Защита данных конфиденциальных учетных данных\n- **Корпоративные системы**: Системы аутентификации сотрудников\n- **Мобильные приложения**: Локальное хранение паролей\n\n**Почему выбрать bcrypt вместо альтернатив:**\n- **Проверено в бою**: Десятилетия использования в реальном мире\n- **Промышленный стандарт**: Рекомендовано экспертами по безопасности и фреймворками\n- **Соответствие нормативам**: Соответствует большинству требований безопасности\n- **Баланс производительности**: Настраиваемый компромисс безопасность против скорости\n- **Широкое принятие**: Поддерживается основными фреймворками (Django, Rails, Spring и др.)\n\n**Лучшие практики:**\n- Использовать стоимость 12 или выше для новых приложений\n- Регулярно пересматривать и увеличивать стоимость по мере улучшения оборудования\n- Никогда не хранить пароли в открытом тексте\n- Использовать bcrypt для паролей, не для общего хеширования\n- Реализовать надлежащую обработку ошибок для предотвращения атак по времени\n\n**Заметка о безопасности:**\n⚠️ **Важно**: Хотя bcrypt отлично подходит для паролей, он не подходит для общего криптографического хеширования. Для целостности файлов, цифровых подписей или других некорректных использований рассмотрите SHA-256, SHA-3 или другие криптографические функции хеширования."
  },
  "pt": {
    "what-is-bcrypt": "O que é bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt é uma função de hash de senhas projetada por Niels Provos e David Mazières em 1999, baseada na cifra Blowfish. É especificamente projetada para fazer hash de senhas com segurança e é amplamente considerada uma das melhores práticas para armazenamento de senhas.\n\n**Características principais:**\n- **Hashing adaptativo**: Usa um parâmetro de custo (fator de trabalho) que o torna mais lento e seguro ao longo do tempo\n- **Integração de salt**: Gera automaticamente e incorpora um salt aleatório para prevenir ataques de tabela arco-íris\n- **Segurança testada pelo tempo**: Mais de 20 anos de uso generalizado sem ataques práticos conhecidos\n- **Dificuldade configurável**: O parâmetro de custo pode ser ajustado para manter a segurança conforme o hardware melhora\n- **Multiplataforma**: Disponível em praticamente todas as linguagens de programação e plataformas\n\n**Como o bcrypt funciona:**\n🔧 **Visão geral do processo**:\n1. **Geração de salt**: Cria um salt aleatório de 128 bits\n2. **Expansão de chave**: Usa a senha e o salt para expandir o cronograma de chaves Blowfish\n3. **Hashing iterativo**: Aplica repetidamente a criptografia Blowfish com o parâmetro de custo determinando as iterações\n4. **Formato de saída**: Produz uma string padronizada contendo versão, custo, salt e hash\n\n**Formato de hash bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ Hash de 31 caracteres (22 chars base64 + 9 chars)\n│ │  └─ Salt de 22 caracteres (codificado em base64)\n│ └─ Parâmetro de custo (4-31, maior = mais lento/mais seguro)\n└─ Identificador de versão ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Vantagens de segurança:**\n✅ **Proteção superior de senhas**:\n- **Lento por design**: Intencionalmente caro computacionalmente para frustrar ataques de força bruta\n- **Salt previne tabelas arco-íris**: Cada senha obtém um salt único\n- **À prova de futuro**: O custo pode ser aumentado conforme o hardware fica mais rápido\n- **Resistente a ataques de tempo**: Tempo de execução consistente independentemente da entrada\n- **Difícil em memória**: Requer memória significativa, tornando ataques paralelos caros\n\n**Guia de parâmetros de custo:**\n- **Custo 10**: ~10ms (mínimo recomendado para 2024)\n- **Custo 12**: ~40ms (bom equilíbrio para a maioria das aplicações)\n- **Custo 14**: ~160ms (aplicações de alta segurança)\n- **Custo 15+**: 300ms+ (segurança máxima, pode impactar a experiência do usuário)\n\n**Casos de uso comuns:**\n- **Aplicações web**: Armazenamento de senhas de contas de usuário\n- **Autenticação de API**: Proteção de chaves de API e tokens\n- **Segurança de banco de dados**: Proteção de dados de credenciais sensíveis\n- **Sistemas empresariais**: Sistemas de autenticação de funcionários\n- **Aplicações móveis**: Armazenamento local de senhas\n\n**Por que escolher bcrypt em vez de alternativas:**\n- **Testado em batalha**: Décadas de uso no mundo real\n- **Padrão da indústria**: Recomendado por especialistas em segurança e frameworks\n- **Conformidade regulatória**: Atende à maioria dos requisitos de conformidade de segurança\n- **Equilíbrio de desempenho**: Trade-off configurável entre segurança e velocidade\n- **Adoção ampla**: Suportado por principais frameworks (Django, Rails, Spring, etc.)\n\n**Melhores práticas:**\n- Usar custo 12 ou superior para novas aplicações\n- Revisar regularmente e aumentar o custo conforme o hardware melhora\n- Nunca armazenar senhas em texto simples\n- Usar bcrypt para senhas, não para hashing de propósito geral\n- Implementar tratamento de erro adequado para prevenir ataques de tempo\n\n**Nota de segurança:**\n⚠️ **Importante**: Embora bcrypt seja excelente para senhas, não é adequado para hashing criptográfico de propósito geral. Para integridade de arquivos, assinaturas digitais ou outros usos não relacionados a senhas, considere SHA-256, SHA-3 ou outras funções de hash criptográficas."
  },
  "ar": {
    "what-is-bcrypt": "ما هو bcrypt؟",
    "what-is-bcrypt-description-markdown": "bcrypt هو دالة تشفير كلمات المرور مصممة من قبل Niels Provos و David Mazières في عام 1999، مبنية على تشفير Blowfish. مصممة خصيصاً لتشفير كلمات المرور بأمان وتُعتبر على نطاق واسع واحدة من أفضل الممارسات لتخزين كلمات المرور.\n\n**الخصائص الرئيسية:**\n- **التشفير التكيفي**: يستخدم معامل التكلفة (عامل العمل) الذي يجعله أبطأ وأكثر أماناً مع مرور الوقت\n- **تكامل الملح**: يولد تلقائياً ويدمج ملحاً عشوائياً لمنع هجمات جدول قوس قزح\n- **الأمان المختبر زمنياً**: أكثر من 20 عاماً من الاستخدام الواسع بدون هجمات عملية معروفة\n- **الصعوبة القابلة للتكوين**: يمكن تعديل معامل التكلفة للحفاظ على الأمان مع تحسن الأجهزة\n- **متعدد المنصات**: متوفر في كل لغات البرمجة والمنصات تقريباً\n\n**كيف يعمل bcrypt:**\n🔧 **نظرة عامة على العملية**:\n1. **توليد الملح**: ينشئ ملحاً عشوائياً بـ 128 بت\n2. **توسيع المفتاح**: يستخدم كلمة المرور والملح لتوسيع جدولة مفاتيح Blowfish\n3. **التشفير التكراري**: يطبق تشفير Blowfish بشكل متكرر مع معامل التكلفة الذي يحدد التكرارات\n4. **تنسيق الإخراج**: ينتج سلسلة نصية موحدة تحتوي على الإصدار والتكلفة والملح والتشفير\n\n**تنسيق تشفير bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ تشفير 31 حرف (22 حرف base64 + 9 أحرف)\n│ │  └─ ملح 22 حرف (مُرمز base64)\n│ └─ معامل التكلفة (4-31، أعلى = أبطأ/أكثر أماناً)\n└─ معرف الإصدار ($2a$، $2b$، $2x$، $2y$)\n```\n\n**مزايا الأمان:**\n✅ **حماية فائقة لكلمات المرور**:\n- **بطيء بالتصميم**: مكلف حاسوبياً عمداً لإحباط هجمات القوة الغاشمة\n- **الملح يمنع جداول قوس قزح**: كل كلمة مرور تحصل على ملح فريد\n- **مقاوم للمستقبل**: يمكن زيادة التكلفة مع تحسن الأجهزة\n- **مقاوم لهجمات التوقيت**: وقت تنفيذ ثابت بغض النظر عن المدخل\n- **صعب الذاكرة**: يتطلب ذاكرة كبيرة، مما يجعل الهجمات المتوازية مكلفة\n\n**دليل معاملات التكلفة:**\n- **التكلفة 10**: حوالي 10 مللي ثانية (الحد الأدنى الموصى به لعام 2024)\n- **التكلفة 12**: حوالي 40 مللي ثانية (توازن جيد لمعظم التطبيقات)\n- **التكلفة 14**: حوالي 160 مللي ثانية (تطبيقات عالية الأمان)\n- **التكلفة 15+**: 300 مللي ثانية+ (أمان أقصى، قد يؤثر على تجربة المستخدم)\n\n**حالات الاستخدام الشائعة:**\n- **تطبيقات الويب**: تخزين كلمات مرور حسابات المستخدمين\n- **مصادقة API**: حماية مفاتيح API والرموز المميزة\n- **أمان قاعدة البيانات**: حماية بيانات الاعتماد الحساسة\n- **الأنظمة المؤسسية**: أنظمة مصادقة الموظفين\n- **التطبيقات المحمولة**: تخزين كلمات المرور محلياً\n\n**لماذا اختيار bcrypt بدلاً من البدائل:**\n- **مختبر في المعركة**: عقود من الاستخدام في العالم الحقيقي\n- **معيار الصناعة**: موصى به من خبراء الأمان والأطر\n- **الامتثال التنظيمي**: يلبي معظم متطلبات الامتثال الأمني\n- **توازن الأداء**: مقايضة قابلة للتكوين بين الأمان والسرعة\n- **اعتماد واسع**: مدعوم من الأطر الرئيسية (Django، Rails، Spring، إلخ)\n\n**أفضل الممارسات:**\n- استخدام تكلفة 12 أو أعلى للتطبيقات الجديدة\n- مراجعة منتظمة وزيادة التكلفة مع تحسن الأجهزة\n- عدم تخزين كلمات المرور في نص واضح أبداً\n- استخدام bcrypt لكلمات المرور، وليس للتشفير العام\n- تنفيذ معالجة أخطاء مناسبة لمنع هجمات التوقيت\n\n**ملاحظة أمنية:**\n⚠️ **مهم**: رغم أن bcrypt ممتاز لكلمات المرور، فهو غير مناسب للتشفير العام. لسلامة الملفات والتوقيعات الرقمية أو الاستخدامات الأخرى غير المتعلقة بكلمات المرور، اعتبر SHA-256 أو SHA-3 أو دوال التشفير الأخرى."
  },
  "hi": {
    "what-is-bcrypt": "bcrypt क्या है?",
    "what-is-bcrypt-description-markdown": "bcrypt एक पासवर्ड हैशिंग फ़ंक्शन है जो 1999 में Niels Provos और David Mazières द्वारा डिज़ाइन किया गया था, जो Blowfish सिफर पर आधारित है। यह विशेष रूप से पासवर्ड को सुरक्षित रूप से हैश करने के लिए डिज़ाइन किया गया है और व्यापक रूप से पासवर्ड भंडारण के सर्वोत्तम प्रथाओं में से एक माना जाता है।\n\n**मुख्य विशेषताएं:**\n- **अनुकूली हैशिंग**: कॉस्ट पैरामीटर (वर्क फैक्टर) का उपयोग करता है जो इसे समय के साथ धीमा और अधिक सुरक्षित बनाता है\n- **नमक एकीकरण**: रेनबो टेबल हमलों को रोकने के लिए स्वचालित रूप से एक यादृच्छिक नमक उत्पन्न करता है और शामिल करता है\n- **समय-परीक्षित सुरक्षा**: 20 साल से अधिक के व्यापक उपयोग के साथ कोई ज्ञात व्यावहारिक हमले नहीं\n- **कॉन्फ़िगरेबल कठिनाई**: हार्डवेयर सुधार के साथ सुरक्षा बनाए रखने के लिए कॉस्ट पैरामीटर को समायोजित किया जा सकता है\n- **क्रॉस-प्लेटफॉर्म**: लगभग हर प्रोग्रामिंग भाषा और प्लेटफॉर्म में उपलब्ध\n\n**bcrypt कैसे काम करता है:**\n🔧 **प्रक्रिया अवलोकन**:\n1. **नमक पीढ़ी**: एक यादृच्छिक 128-बिट नमक बनाता है\n2. **की विस्तार**: Blowfish की शेड्यूल का विस्तार करने के लिए पासवर्ड और नमक का उपयोग करता है\n3. **पुनरावृत्ति हैशिंग**: कॉस्ट पैरामीटर द्वारा निर्धारित पुनरावृत्तियों के साथ Blowfish एन्क्रिप्शन को बार-बार लागू करता है\n4. **आउटपुट प्रारूप**: संस्करण, कॉस्ट, नमक और हैश युक्त मानकीकृत स्ट्रिंग उत्पन्न करता है\n\n**bcrypt हैश प्रारूप:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31-वर्ण हैश (22 वर्ण base64 + 9 वर्ण)\n│ │  └─ 22-वर्ण नमक (base64 एन्कोडेड)\n│ └─ कॉस्ट पैरामीटर (4-31, उच्चतर = धीमा/अधिक सुरक्षित)\n└─ संस्करण पहचानकर्ता ($2a$, $2b$, $2x$, $2y$)\n```\n\n**सुरक्षा लाभ:**\n✅ **श्रेष्ठ पासवर्ड सुरक्षा**:\n- **डिज़ाइन द्वारा धीमा**: ब्रूट फोर्स हमलों को विफल करने के लिए जानबूझकर कम्प्यूटेशनल रूप से महंगा\n- **नमक रेनबो टेबल को रोकता है**: प्रत्येक पासवर्ड को एक अनोखा नमक मिलता है\n- **भविष्य-प्रूफ**: हार्डवेयर तेज़ होने पर कॉस्ट बढ़ाया जा सकता है\n- **टाइमिंग अटैक प्रतिरोधी**: इनपुट की परवाह किए बिना सुसंगत निष्पादन समय\n- **मेमोरी-हार्ड**: महत्वपूर्ण मेमोरी की आवश्यकता, समानांतर हमलों को महंगा बनाता है\n\n**कॉस्ट पैरामीटर गाइड:**\n- **कॉस्ट 10**: ~10ms (2024 के लिए अनुशंसित न्यूनतम)\n- **कॉस्ट 12**: ~40ms (अधिकांश एप्लिकेशन के लिए अच्छा संतुलन)\n- **कॉस्ट 14**: ~160ms (उच्च सुरक्षा एप्लिकेशन)\n- **कॉस्ट 15+**: 300ms+ (अधिकतम सुरक्षा, उपयोगकर्ता अनुभव को प्रभावित कर सकता है)\n\n**सामान्य उपयोग के मामले:**\n- **वेब एप्लिकेशन**: उपयोगकर्ता खाता पासवर्ड भंडारण\n- **API प्रमाणीकरण**: API कीज़ और टोकन की सुरक्षा\n- **डेटाबेस सुरक्षा**: संवेदनशील क्रेडेंशियल डेटा की सुरक्षा\n- **एंटरप्राइज़ सिस्टम**: कर्मचारी प्रमाणीकरण सिस्टम\n- **मोबाइल एप्लिकेशन**: स्थानीय पासवर्ड भंडारण\n\n**विकल्पों पर bcrypt क्यों चुनें:**\n- **युद्ध-परीक्षित**: दशकों का वास्तविक-विश्व उपयोग\n- **उद्योग मानक**: सुरक्षा विशेषज्ञों और फ्रेमवर्क द्वारा अनुशंसित\n- **नियामक अनुपालन**: अधिकांश सुरक्षा अनुपालन आवश्यकताओं को पूरा करता है\n- **प्रदर्शन संतुलन**: कॉन्फ़िगरेबल सुरक्षा बनाम गति ट्रेड-ऑफ\n- **व्यापक अपनाना**: प्रमुख फ्रेमवर्क (Django, Rails, Spring, आदि) द्वारा समर्थित\n\n**सर्वोत्तम प्रथाएं:**\n- नए एप्लिकेशन के लिए कॉस्ट 12 या उससे अधिक का उपयोग करें\n- नियमित रूप से समीक्षा करें और हार्डवेयर सुधार के साथ कॉस्ट बढ़ाएं\n- कभी भी सादे टेक्स्ट पासवर्ड स्टोर न करें\n- पासवर्ड के लिए bcrypt का उपयोग करें, सामान्य-उद्देश्य हैशिंग के लिए नहीं\n- टाइमिंग हमलों को रोकने के लिए उचित त्रुटि हैंडलिंग लागू करें\n\n**सुरक्षा नोट:**\n⚠️ **महत्वपूर्ण**: जबकि bcrypt पासवर्ड के लिए उत्कृष्ट है, यह सामान्य-उद्देश्य क्रिप्टोग्राफिक हैशिंग के लिए उपयुक्त नहीं है। फ़ाइल अखंडता, डिजिटल हस्ताक्षर या अन्य गैर-पासवर्ड उपयोगों के लिए SHA-256, SHA-3 या अन्य क्रिप्टोग्राफिक हैश फ़ंक्शन पर विचार करें।"
  },
  "tr": {
    "what-is-bcrypt": "bcrypt nedir?",
    "what-is-bcrypt-description-markdown": "bcrypt, 1999 yılında Niels Provos ve David Mazières tarafından tasarlanan ve Blowfish şifresine dayanan bir parola hash fonksiyonudur. Özellikle parolaları güvenli bir şekilde hash'lemek için tasarlanmış ve parola depolama için en iyi uygulamalardan biri olarak yaygın şekilde kabul edilmektedir.\n\n**Ana özellikler:**\n- **Uyarlanabilir hash'leme**: Zaman içinde daha yavaş ve güvenli hale getiren bir maliyet parametresi (iş faktörü) kullanır\n- **Tuz entegrasyonu**: Gökkuşağı tablosu saldırılarını önlemek için otomatik olarak rastgele tuz oluşturur ve dahil eder\n- **Zamanla test edilmiş güvenlik**: 20 yıldan fazla yaygın kullanım ile bilinen pratik saldırılar yok\n- **Yapılandırılabilir zorluk**: Donanım gelişimi ile güvenliği korumak için maliyet parametresi ayarlanabilir\n- **Çapraz platform**: Neredeyse her programlama dili ve platformda mevcut\n\n**bcrypt nasıl çalışır:**\n🔧 **İşlem genel bakış**:\n1. **Tuz üretimi**: Rastgele 128-bit tuz oluşturur\n2. **Anahtar genişletme**: Blowfish anahtar çizelgesini genişletmek için parola ve tuzu kullanır\n3. **Yinelemeli hash'leme**: Maliyet parametresinin yinelemeleri belirlediği Blowfish şifrelemesini tekrar tekrar uygular\n4. **Çıktı formatı**: Sürüm, maliyet, tuz ve hash içeren standartlaştırılmış dize üretir\n\n**bcrypt hash formatı:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31 karakterlik hash (22 karakter base64 + 9 karakter)\n│ │  └─ 22 karakterlik tuz (base64 kodlu)\n│ └─ Maliyet parametresi (4-31, yüksek = yavaş/daha güvenli)\n└─ Sürüm tanımlayıcısı ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Güvenlik avantajları:**\n✅ **Üstün parola koruması**:\n- **Tasarım gereği yavaş**: Brute force saldırılarını engellemek için kasıtlı olarak hesaplama açısından pahalı\n- **Tuz gökkuşağı tablolarını önler**: Her parola benzersiz bir tuz alır\n- **Geleceğe dönük**: Donanım hızlandıkça maliyet artırılabilir\n- **Zamanlama saldırı dirençli**: Girişten bağımsız tutarlı yürütme süresi\n- **Bellek zorlu**: Önemli bellek gerektirir, paralel saldırıları pahalı hale getirir\n\n**Maliyet parametresi rehberi:**\n- **Maliyet 10**: ~10ms (2024 için önerilen minimum)\n- **Maliyet 12**: ~40ms (çoğu uygulama için iyi denge)\n- **Maliyet 14**: ~160ms (yüksek güvenlik uygulamaları)\n- **Maliyet 15+**: 300ms+ (maksimum güvenlik, kullanıcı deneyimini etkileyebilir)\n\n**Yaygın kullanım durumları:**\n- **Web uygulamaları**: Kullanıcı hesabı parola depolama\n- **API kimlik doğrulama**: API anahtarları ve token'ların güvenliği\n- **Veritabanı güvenliği**: Hassas kimlik bilgisi verilerinin korunması\n- **Kurumsal sistemler**: Çalışan kimlik doğrulama sistemleri\n- **Mobil uygulamalar**: Yerel parola depolama\n\n**Alternatiflere göre bcrypt neden tercih edilir:**\n- **Savaş testli**: Onlarca yıllık gerçek dünya kullanımı\n- **Endüstri standardı**: Güvenlik uzmanları ve framework'ler tarafından önerilen\n- **Düzenleyici uyumluluk**: Çoğu güvenlik uyumluluk gereksinimini karşılar\n- **Performans dengesi**: Yapılandırılabilir güvenlik vs hız ödünleşimi\n- **Geniş benimseme**: Ana framework'ler (Django, Rails, Spring, vb.) tarafından desteklenen\n\n**En iyi uygulamalar:**\n- Yeni uygulamalar için maliyet 12 veya daha yüksek kullanın\n- Düzenli olarak gözden geçirin ve donanım gelişimi ile maliyeti artırın\n- Asla düz metin parolaları saklamayın\n- Parolalar için bcrypt kullanın, genel amaçlı hash'leme için değil\n- Zamanlama saldırılarını önlemek için uygun hata işleme uygulayın\n\n**Güvenlik notu:**\n⚠️ **Önemli**: bcrypt parolalar için mükemmel olsa da, genel amaçlı kriptografik hash'leme için uygun değildir. Dosya bütünlüğü, dijital imzalar veya diğer parola dışı kullanımlar için SHA-256, SHA-3 veya diğer kriptografik hash fonksiyonlarını düşünün."
  },
  "nl": {
    "what-is-bcrypt": "Wat is bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt is een wachtwoord hash-functie ontworpen door Niels Provos en David Mazières in 1999, gebaseerd op het Blowfish-cijfer. Het is specifiek ontworpen voor het veilig hashen van wachtwoorden en wordt algemeen beschouwd als een van de beste praktijken voor wachtwoordopslag.\n\n**Belangrijkste kenmerken:**\n- **Adaptieve hashing**: Gebruikt een kostenparameter (werkfactor) die het langzamer en veiliger maakt in de tijd\n- **Zout integratie**: Genereert automatisch en integreert een willekeurig zout om regenboogtabel-aanvallen te voorkomen\n- **Tijdbeproefde veiligheid**: Meer dan 20 jaar wijdverspreid gebruik zonder bekende praktische aanvallen\n- **Configureerbare moeilijkheid**: De kostenparameter kan worden aangepast om veiligheid te behouden naarmate hardware verbetert\n- **Cross-platform**: Beschikbaar in vrijwel elke programmeertaal en platform\n\n**Hoe bcrypt werkt:**\n🔧 **Procesoverzicht**:\n1. **Zoutgeneratie**: Creëert een willekeurig 128-bit zout\n2. **Sleuteluitbreiding**: Gebruikt wachtwoord en zout om het Blowfish-sleutelschema uit te breiden\n3. **Iteratieve hashing**: Past herhaaldelijk Blowfish-versleuteling toe met de kostenparameter die iteraties bepaalt\n4. **Uitvoerformaat**: Produceert een gestandaardiseerde string met versie, kosten, zout en hash\n\n**bcrypt hash-formaat:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31-karakter hash (22 chars base64 + 9 chars)\n│ │  └─ 22-karakter zout (base64 gecodeerd)\n│ └─ Kostenparameter (4-31, hoger = langzamer/veiliger)\n└─ Versie-identificator ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Veiligheidsvoordelen:**\n✅ **Superieure wachtwoordbescherming**:\n- **Langzaam by design**: Opzettelijk computationeel duur om brute force-aanvallen te dwarsbomen\n- **Zout voorkomt regenboogtabellen**: Elk wachtwoord krijgt een uniek zout\n- **Toekomstbestendig**: Kosten kunnen worden verhoogd naarmate hardware sneller wordt\n- **Timing attack-resistent**: Consistente uitvoeringstijd ongeacht invoer\n- **Geheugen-zwaar**: Vereist aanzienlijk geheugen, maakt parallelle aanvallen duur\n\n**Kostenparameter gids:**\n- **Kosten 10**: ~10ms (aanbevolen minimum voor 2024)\n- **Kosten 12**: ~40ms (goede balans voor meeste applicaties)\n- **Kosten 14**: ~160ms (hoge beveiligingsapplicaties)\n- **Kosten 15+**: 300ms+ (maximale beveiliging, kan gebruikerservaring beïnvloeden)\n\n**Veelvoorkomende gebruikssituaties:**\n- **Webapplicaties**: Gebruikersaccount wachtwoordopslag\n- **API-authenticatie**: Beveiliging van API-sleutels en tokens\n- **Databasebeveiliging**: Bescherming van gevoelige inloggegevens\n- **Bedrijfssystemen**: Werknemersauthenticatiesystemen\n- **Mobiele applicaties**: Lokale wachtwoordopslag\n\n**Waarom bcrypt kiezen boven alternatieven:**\n- **Gevechtsproefd**: Decennia van gebruik in de echte wereld\n- **Industriestandaard**: Aanbevolen door beveiligingsexperts en frameworks\n- **Regulatory compliance**: Voldoet aan de meeste beveiligingsnalevingsvereisten\n- **Prestatie balans**: Configureerbare beveiliging vs snelheid afweging\n- **Brede adoptie**: Ondersteund door grote frameworks (Django, Rails, Spring, etc.)\n\n**Beste praktijken:**\n- Gebruik kosten 12 of hoger voor nieuwe applicaties\n- Regelmatig herzien en kosten verhogen naarmate hardware verbetert\n- Sla nooit platte tekst wachtwoorden op\n- Gebruik bcrypt voor wachtwoorden, niet voor algemene hashing\n- Implementeer juiste foutafhandeling om timing-aanvallen te voorkomen\n\n**Veiligheidsnoot:**\n⚠️ **Belangrijk**: Hoewel bcrypt uitstekend is voor wachtwoorden, is het niet geschikt voor algemene cryptografische hashing. Voor bestandsintegriteit, digitale handtekeningen of andere niet-wachtwoord toepassingen, overweeg SHA-256, SHA-3 of andere cryptografische hash-functies."
  },
  "sv": {
    "what-is-bcrypt": "Vad är bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt är en lösenords-hash-funktion designad av Niels Provos och David Mazières 1999, baserad på Blowfish-chifferet. Den är specifikt designad för säker hashning av lösenord och anses allmänt som en av de bästa metoderna för lösenordslagring.\n\n**Nyckelegenskaper:**\n- **Adaptiv hashning**: Använder en kostparameter (arbetsfaktor) som gör det långsammare och säkrare över tid\n- **Saltintegration**: Genererar automatiskt och inkorporerar ett slumpmässigt salt för att förhindra regnbågstabellattacker\n- **Tidstestad säkerhet**: Över 20 års utbredd användning utan kända praktiska attacker\n- **Konfigurerbar svårighet**: Kostparametern kan justeras för att upprätthålla säkerhet när hårdvara förbättras\n- **Plattformsoberoende**: Tillgänglig i praktiskt taget alla programmeringsspråk och plattformar\n\n**Hur bcrypt fungerar:**\n🔧 **Processöversikt**:\n1. **Saltgenerering**: Skapar ett slumpmässigt 128-bitars salt\n2. **Nyckelexpansion**: Använder lösenord och salt för att expandera Blowfish-nyckelschema\n3. **Iterativ hashning**: Tillämpar upprepat Blowfish-kryptering med kostparametern som bestämmer iterationer\n4. **Utmatningsformat**: Producerar en standardiserad sträng som innehåller version, kostnad, salt och hash\n\n**bcrypt hash-format:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31-tecken hash (22 tecken base64 + 9 tecken)\n│ │  └─ 22-tecken salt (base64-kodad)\n│ └─ Kostparameter (4-31, högre = långsammare/säkrare)\n└─ Versionsidentifierare ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Säkerhetsfördelar:**\n✅ **Överlägsen lösenordsskydd**:\n- **Långsam by design**: Avsiktligt beräkningsmässigt dyr för att motverka brute force-attacker\n- **Salt förhindrar regnbågstabeller**: Varje lösenord får ett unikt salt\n- **Framtidssäker**: Kostnad kan ökas när hårdvara blir snabbare\n- **Timing attack-resistent**: Konsekvent exekveringstid oberoende av inmatning\n- **Minnessvår**: Kräver betydande minne, gör parallella attacker dyra\n\n**Kostparameter-guide:**\n- **Kostnad 10**: ~10ms (rekommenderat minimum för 2024)\n- **Kostnad 12**: ~40ms (bra balans för de flesta applikationer)\n- **Kostnad 14**: ~160ms (högsäkerhetsapplikationer)\n- **Kostnad 15+**: 300ms+ (maximal säkerhet, kan påverka användarupplevelse)\n\n**Vanliga användningsfall:**\n- **Webbapplikationer**: Lagring av användarkontolösenord\n- **API-autentisering**: Säkra API-nycklar och tokens\n- **Databassäkerhet**: Skydda känsliga inloggningsdata\n- **Företagssystem**: Medarbetarautentiseringssystem\n- **Mobilapplikationer**: Lokal lösenordslagring\n\n**Varför välja bcrypt över alternativ:**\n- **Stridstestad**: Decennier av verklig användning\n- **Branschstandard**: Rekommenderad av säkerhetsexperter och ramverk\n- **Regulatorisk efterlevnad**: Uppfyller de flesta säkerhetsefterlevnadskrav\n- **Prestanda balans**: Konfigurerbar säkerhet vs hastighetsavvägning\n- **Bred adoption**: Stöds av stora ramverk (Django, Rails, Spring, etc.)\n\n**Bästa praxis:**\n- Använd kostnad 12 eller högre för nya applikationer\n- Granska regelbundet och öka kostnad när hårdvara förbättras\n- Lagra aldrig lösenord i klartext\n- Använd bcrypt för lösenord, inte för allmän hashning\n- Implementera korrekt felhantering för att förhindra timing-attacker\n\n**Säkerhetsnotering:**\n⚠️ **Viktigt**: Medan bcrypt är utmärkt för lösenord, är det inte lämpligt för allmän kryptografisk hashning. För filintegritet, digitala signaturer eller andra icke-lösenordsanvändningar, överväg SHA-256, SHA-3 eller andra kryptografiska hash-funktioner."
  },
  "pl": {
    "what-is-bcrypt": "Czym jest bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt to funkcja hash'ująca hasła zaprojektowana przez Niels Provos i David Mazières w 1999 roku, oparta na szyfrze Blowfish. Jest specjalnie zaprojektowana do bezpiecznego hash'owania haseł i jest szeroko uważana za jedną z najlepszych praktyk przechowywania haseł.\n\n**Kluczowe cechy:**\n- **Adaptacyjne hash'owanie**: Używa parametru kosztu (współczynnik pracy), który czyni go wolniejszym i bezpieczniejszym w czasie\n- **Integracja soli**: Automatycznie generuje i włącza losową sól, aby zapobiec atakom rainbow table\n- **Sprawdzone czasem bezpieczeństwo**: Ponad 20 lat szerokiego użycia bez znanych praktycznych ataków\n- **Konfigurowalna trudność**: Parametr kosztu może być dostosowany, aby utrzymać bezpieczeństwo wraz z poprawą sprzętu\n- **Wieloplatformowość**: Dostępne w praktycznie każdym języku programowania i platformie\n\n**Jak działa bcrypt:**\n🔧 **Przegląd procesu**:\n1. **Generowanie soli**: Tworzy losową 128-bitową sól\n2. **Rozszerzenie klucza**: Używa hasła i soli do rozszerzenia harmonogramu kluczy Blowfish\n3. **Iteracyjne hash'owanie**: Wielokrotnie stosuje szyfrowanie Blowfish z parametrem kosztu określającym iteracje\n4. **Format wyjściowy**: Produkuje znormalizowany ciąg zawierający wersję, koszt, sól i hash\n\n**Format hash'a bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31-znakowy hash (22 znaki base64 + 9 znaków)\n│ │  └─ 22-znakowa sól (kodowana base64)\n│ └─ Parametr kosztu (4-31, wyższy = wolniejszy/bezpieczniejszy)\n└─ Identyfikator wersji ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Zalety bezpieczeństwa:**\n✅ **Doskonała ochrona haseł**:\n- **Wolny z założenia**: Celowo kosztowny obliczeniowo, aby udaremnić ataki brute force\n- **Sól zapobiega rainbow tables**: Każde hasło otrzymuje unikalną sól\n- **Odporny na przyszłość**: Koszt może być zwiększany wraz z przyspieszaniem sprzętu\n- **Odporny na ataki czasowe**: Spójny czas wykonania niezależnie od wejścia\n- **Wymagający pamięci**: Wymaga znacznej pamięci, czyniąc ataki równoległe kosztownymi\n\n**Przewodnik parametrów kosztu:**\n- **Koszt 10**: ~10ms (zalecane minimum dla 2024)\n- **Koszt 12**: ~40ms (dobra równowaga dla większości aplikacji)\n- **Koszt 14**: ~160ms (aplikacje wysokiego bezpieczeństwa)\n- **Koszt 15+**: 300ms+ (maksymalne bezpieczeństwo, może wpłynąć na doświadczenie użytkownika)\n\n**Powszechne przypadki użycia:**\n- **Aplikacje webowe**: Przechowywanie haseł kont użytkowników\n- **Uwierzytelnianie API**: Zabezpieczanie kluczy API i tokenów\n- **Bezpieczeństwo bazy danych**: Ochrona wrażliwych danych uwierzytelniających\n- **Systemy korporacyjne**: Systemy uwierzytelniania pracowników\n- **Aplikacje mobilne**: Lokalne przechowywanie haseł\n\n**Dlaczego wybrać bcrypt zamiast alternatyw:**\n- **Sprawdzony w boju**: Dziesięciolecia rzeczywistego użycia\n- **Standard branży**: Zalecany przez ekspertów bezpieczeństwa i frameworki\n- **Zgodność regulacyjna**: Spełnia większość wymagań zgodności bezpieczeństwa\n- **Równowaga wydajności**: Konfigurowalna wymiana bezpieczeństwa vs szybkości\n- **Szerokie przyjęcie**: Wspierane przez główne frameworki (Django, Rails, Spring, itp.)\n\n**Najlepsze praktyki:**\n- Używaj kosztu 12 lub wyższego dla nowych aplikacji\n- Regularnie przeglądaj i zwiększaj koszt wraz z poprawą sprzętu\n- Nigdy nie przechowuj haseł w postaci jawnej\n- Używaj bcrypt dla haseł, nie do ogólnego hash'owania\n- Implementuj właściwą obsługę błędów, aby zapobiec atakom czasowym\n\n**Nota bezpieczeństwa:**\n⚠️ **Ważne**: Choć bcrypt jest doskonały dla haseł, nie jest odpowiedni do ogólnego hash'owania kryptograficznego. Do integralności plików, podpisów cyfrowych lub innych zastosowań nie związanych z hasłami, rozważ SHA-256, SHA-3 lub inne funkcje hash'ujące kryptograficzne."
  },
  "vi": {
    "what-is-bcrypt": "bcrypt là gì?",
    "what-is-bcrypt-description-markdown": "bcrypt là một hàm băm mật khẩu được thiết kế bởi Niels Provos và David Mazières vào năm 1999, dựa trên mã hóa Blowfish. Nó được thiết kế đặc biệt để băm mật khẩu một cách an toàn và được coi là một trong những thực hành tốt nhất cho việc lưu trữ mật khẩu.\n\n**Đặc điểm chính:**\n- **Băm thích ứng**: Sử dụng tham số chi phí (hệ số công việc) làm cho nó chậm hơn và an toàn hơn theo thời gian\n- **Tích hợp muối**: Tự động tạo và kết hợp muối ngẫu nhiên để ngăn chặn các cuộc tấn công bảng cầu vồng\n- **Bảo mật đã được kiểm chứng theo thời gian**: Hơn 20 năm sử dụng rộng rãi mà không có cuộc tấn công thực tế nào được biết đến\n- **Độ khó có thể cấu hình**: Tham số chi phí có thể được điều chỉnh để duy trì bảo mật khi phần cứng được cải thiện\n- **Đa nền tảng**: Có sẵn trong hầu hết mọi ngôn ngữ lập trình và nền tảng\n\n**Cách bcrypt hoạt động:**\n🔧 **Tổng quan quy trình**:\n1. **Tạo muối**: Tạo một muối ngẫu nhiên 128-bit\n2. **Mở rộng khóa**: Sử dụng mật khẩu và muối để mở rộng lịch trình khóa Blowfish\n3. **Băm lặp**: Áp dụng mã hóa Blowfish nhiều lần với tham số chi phí xác định số lần lặp\n4. **Định dạng đầu ra**: Tạo ra một chuỗi tiêu chuẩn chứa phiên bản, chi phí, muối và băm\n\n**Định dạng băm bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ Băm 31 ký tự (22 ký tự base64 + 9 ký tự)\n│ │  └─ Muối 22 ký tự (mã hóa base64)\n│ └─ Tham số chi phí (4-31, cao hơn = chậm hơn/an toàn hơn)\n└─ Định danh phiên bản ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Ưu điểm bảo mật:**\n✅ **Bảo vệ mật khẩu vượt trội**:\n- **Chậm theo thiết kế**: Cố ý tốn kém về mặt tính toán để ngăn chặn các cuộc tấn công brute force\n- **Muối ngăn chặn bảng cầu vồng**: Mỗi mật khẩu nhận được một muối duy nhất\n- **Bền vững tương lai**: Chi phí có thể được tăng lên khi phần cứng trở nên nhanh hơn\n- **Kháng tấn công thời gian**: Thời gian thực thi nhất quán bất kể đầu vào\n- **Khó về bộ nhớ**: Yêu cầu bộ nhớ đáng kể, làm cho các cuộc tấn công song song trở nên tốn kém\n\n**Hướng dẫn tham số chi phí:**\n- **Chi phí 10**: ~10ms (tối thiểu được khuyến nghị cho 2024)\n- **Chi phí 12**: ~40ms (cân bằng tốt cho hầu hết các ứng dụng)\n- **Chi phí 14**: ~160ms (ứng dụng bảo mật cao)\n- **Chi phí 15+**: 300ms+ (bảo mật tối đa, có thể ảnh hưởng đến trải nghiệm người dùng)\n\n**Các trường hợp sử dụng phổ biến:**\n- **Ứng dụng web**: Lưu trữ mật khẩu tài khoản người dùng\n- **Xác thực API**: Bảo vệ khóa API và token\n- **Bảo mật cơ sở dữ liệu**: Bảo vệ dữ liệu thông tin đăng nhập nhạy cảm\n- **Hệ thống doanh nghiệp**: Hệ thống xác thực nhân viên\n- **Ứng dụng di động**: Lưu trữ mật khẩu cục bộ\n\n**Tại sao chọn bcrypt thay vì các phương án khác:**\n- **Đã được thử nghiệm trong thực tế**: Hàng thập kỷ sử dụng trong thế giới thực\n- **Tiêu chuẩn ngành**: Được khuyến nghị bởi các chuyên gia bảo mật và framework\n- **Tuân thủ quy định**: Đáp ứng hầu hết các yêu cầu tuân thủ bảo mật\n- **Cân bằng hiệu suất**: Sự đánh đổi có thể cấu hình giữa bảo mật và tốc độ\n- **Áp dụng rộng rãi**: Được hỗ trợ bởi các framework chính (Django, Rails, Spring, v.v.)\n\n**Thực hành tốt nhất:**\n- Sử dụng chi phí 12 hoặc cao hơn cho các ứng dụng mới\n- Định kỳ xem xét và tăng chi phí khi phần cứng được cải thiện\n- Không bao giờ lưu trữ mật khẩu văn bản thuần\n- Sử dụng bcrypt cho mật khẩu, không phải cho băm mục đích chung\n- Triển khai xử lý lỗi phù hợp để ngăn chặn các cuộc tấn công thời gian\n\n**Lưu ý bảo mật:**\n⚠️ **Quan trọng**: Mặc dù bcrypt xuất sắc cho mật khẩu, nó không phù hợp cho băm mã hóa mục đích chung. Đối với tính toàn vẹn tệp, chữ ký số hoặc các sử dụng khác không phải mật khẩu, hãy xem xét SHA-256, SHA-3 hoặc các hàm băm mã hóa khác."
  },
  "th": {
    "what-is-bcrypt": "bcrypt คืออะไร?",
    "what-is-bcrypt-description-markdown": "bcrypt เป็นฟังก์ชันแฮชรหัสผ่านที่ออกแบบโดย Niels Provos และ David Mazières ในปี 1999 โดยอิงจากการเข้ารหัส Blowfish ถูกออกแบบมาเฉพาะสำหรับการแฮชรหัสผ่านอย่างปลอดภัย และได้รับการยอมรับอย่างกว้างขวางว่าเป็นหนึ่งในแนวทางปฏิบัติที่ดีที่สุดสำหรับการจัดเก็บรหัสผ่าน\n\n**คุณลักษณะสำคัญ:**\n- **การแฮชแบบปรับตัว**: ใช้พารามิเตอร์ต้นทุน (ปัจจัยการทำงาน) ที่ทำให้ช้าลงและปลอดภัยขึ้นตามเวลา\n- **การรวมเกลือ**: สร้างและรวมเกลือแบบสุ่มโดยอัตโนมัติเพื่อป้องกันการโจมตีตารางรุ้ง\n- **ความปลอดภัยที่ผ่านการทดสอบตามเวลา**: การใช้งานอย่างแพร่หลายมากว่า 20 ปีโดยไม่มีการโจมตีเชิงปฏิบัติที่ทราบ\n- **ความยากที่กำหนดได้**: สามารถปรับพารามิเตอร์ต้นทุนเพื่อรักษาความปลอดภัยเมื่อฮาร์ดแวร์ดีขึ้น\n- **ข้ามแพลตฟอร์ม**: พร้อมใช้งานในเกือบทุกภาษาโปรแกรมมิ่งและแพลตฟอร์ม\n\n**วิธีการทำงานของ bcrypt:**\n🔧 **ภาพรวมของกระบวนการ**:\n1. **การสร้างเกลือ**: สร้างเกลือแบบสุ่ม 128 บิต\n2. **การขยายคีย์**: ใช้รหัสผ่านและเกลือเพื่อขยายตารางคีย์ Blowfish\n3. **การแฮชแบบซ้ำ**: ใช้การเข้ารหัส Blowfish ซ้ำ ๆ โดยพารามิเตอร์ต้นทุนกำหนดการซ้ำ\n4. **รูปแบบเอาต์พุต**: สร้างสตริงมาตรฐานที่มีเวอร์ชัน ต้นทุน เกลือ และแฮช\n\n**รูปแบบแฮช bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ แฮช 31 ตัวอักษร (22 ตัวอักษร base64 + 9 ตัวอักษร)\n│ │  └─ เกลือ 22 ตัวอักษร (เข้ารหัส base64)\n│ └─ พารามิเตอร์ต้นทุน (4-31, สูงกว่า = ช้ากว่า/ปลอดภัยกว่า)\n└─ ตัวระบุเวอร์ชัน ($2a$, $2b$, $2x$, $2y$)\n```\n\n**ข้อดีด้านความปลอดภัย:**\n✅ **การป้องกันรหัสผ่านที่เหนือกว่า**:\n- **ช้าโดยการออกแบบ**: แพงทางการคำนวณโดยเจตนาเพื่อขัดขวางการโจมตีแบบ brute force\n- **เกลือป้องกันตารางรุ้ง**: รหัสผ่านแต่ละรายการได้รับเกลือที่ไม่ซ้ำ\n- **พร้อมสำหรับอนาคต**: สามารถเพิ่มต้นทุนเมื่อฮาร์ดแวร์เร็วขึ้น\n- **ทนต่อการโจมตีเวลา**: เวลาดำเนินการสม่ำเสมอไม่ว่าข้อมูลนำเข้าจะเป็นอย่างไร\n- **หนักหน่วยความจำ**: ต้องการหน่วยความจำจำนวนมาก ทำให้การโจมตีแบบขนานมีราคาแพง\n\n**คู่มือพารามิเตอร์ต้นทุน:**\n- **ต้นทุน 10**: ~10ms (ค่าต่ำสุดที่แนะนำสำหรับ 2024)\n- **ต้นทุน 12**: ~40ms (สมดุลที่ดีสำหรับแอปพลิเคชันส่วนใหญ่)\n- **ต้นทุน 14**: ~160ms (แอปพลิเคชันความปลอดภัยสูง)\n- **ต้นทุน 15+**: 300ms+ (ความปลอดภัยสูงสุด อาจส่งผลต่อประสบการณ์ผู้ใช้)\n\n**กรณีการใช้งานทั่วไป:**\n- **แอปพลิเคชันเว็บ**: การจัดเก็บรหัสผ่านบัญชีผู้ใช้\n- **การยืนยันตัวตน API**: การรักษาความปลอดภัยของคีย์ API และโทเค็น\n- **ความปลอดภัยฐานข้อมูล**: การป้องกันข้อมูลข้อมูลประจำตัวที่ละเอียดอ่อน\n- **ระบบองค์กร**: ระบบยืนยันตัวตนพนักงาน\n- **แอปพลิเคชันมือถือ**: การจัดเก็บรหัสผ่านในเครื่อง\n\n**ทำไมต้องเลือก bcrypt แทนทางเลือกอื่น:**\n- **ผ่านการทดสอบในสนามรบ**: การใช้งานในโลกแห่งความเป็นจริงมาหลายทศวรรษ\n- **มาตรฐานอุตสาหกรรม**: แนะนำโดยผู้เชี่ยวชาญด้านความปลอดภัยและเฟรมเวิร์ก\n- **การปฏิบัติตามกฎระเบียบ**: ตอบสนองความต้องการการปฏิบัติตามกฎระเบียบความปลอดภัยส่วนใหญ่\n- **สมดุลประสิทธิภาพ**: การแลกเปลี่ยนความปลอดภัยกับความเร็วที่กำหนดได้\n- **การยอมรับอย่างกว้างขวาง**: รองรับโดยเฟรมเวิร์กหลัก (Django, Rails, Spring ฯลฯ)\n\n**แนวทางปฏิบัติที่ดีที่สุด:**\n- ใช้ต้นทุน 12 หรือสูงกว่าสำหรับแอปพลิเคชันใหม่\n- ทบทวนเป็นประจำและเพิ่มต้นทุนเมื่อฮาร์ดแวร์ดีขึ้น\n- อย่าจัดเก็บรหัสผ่านข้อความธรรมดา\n- ใช้ bcrypt สำหรับรหัสผ่าน ไม่ใช่สำหรับการแฮชทั่วไป\n- ใช้การจัดการข้อผิดพลาดที่เหมาะสมเพื่อป้องกันการโจมตีเวลา\n\n**หมายเหตุความปลอดภัย:**\n⚠️ **สำคัญ**: แม้ว่า bcrypt จะยอดเยี่ยมสำหรับรหัสผ่าน แต่ไม่เหมาะสำหรับการแฮชเข้ารหัสทั่วไป สำหรับความสมบูรณ์ของไฟล์ ลายเซ็นดิจิทัล หรือการใช้งานอื่น ๆ ที่ไม่ใช่รหัสผ่าน ให้พิจารณา SHA-256, SHA-3 หรือฟังก์ชันแฮชเข้ารหัสอื่น ๆ"
  },
  "id": {
    "what-is-bcrypt": "Apa itu bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt adalah fungsi hash password yang dirancang oleh Niels Provos dan David Mazières pada 1999, berdasarkan cipher Blowfish. Dirancang khusus untuk melakukan hash password secara aman dan dianggap secara luas sebagai salah satu praktik terbaik untuk penyimpanan password.\n\n**Karakteristik utama:**\n- **Hashing adaptif**: Menggunakan parameter biaya (faktor kerja) yang membuatnya lebih lambat dan lebih aman seiring waktu\n- **Integrasi salt**: Secara otomatis menghasilkan dan menggabungkan salt acak untuk mencegah serangan rainbow table\n- **Keamanan yang teruji waktu**: Lebih dari 20 tahun penggunaan luas tanpa serangan praktis yang diketahui\n- **Kesulitan yang dapat dikonfigurasi**: Parameter biaya dapat disesuaikan untuk mempertahankan keamanan seiring peningkatan hardware\n- **Cross-platform**: Tersedia di hampir setiap bahasa pemrograman dan platform\n\n**Cara kerja bcrypt:**\n🔧 **Gambaran proses**:\n1. **Generasi salt**: Membuat salt acak 128-bit\n2. **Ekspansi kunci**: Menggunakan password dan salt untuk memperluas jadwal kunci Blowfish\n3. **Hashing iteratif**: Berulang kali menerapkan enkripsi Blowfish dengan parameter biaya menentukan iterasi\n4. **Format output**: Menghasilkan string standar yang berisi versi, biaya, salt, dan hash\n\n**Format hash bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ Hash 31 karakter (22 karakter base64 + 9 karakter)\n│ │  └─ Salt 22 karakter (dikodekan base64)\n│ └─ Parameter biaya (4-31, lebih tinggi = lebih lambat/lebih aman)\n└─ Pengenal versi ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Keuntungan keamanan:**\n✅ **Perlindungan password yang superior**:\n- **Lambat berdasarkan desain**: Sengaja mahal secara komputasi untuk menggagalkan serangan brute force\n- **Salt mencegah rainbow table**: Setiap password mendapat salt yang unik\n- **Tahan masa depan**: Biaya dapat ditingkatkan seiring hardware menjadi lebih cepat\n- **Tahan serangan timing**: Waktu eksekusi yang konsisten terlepas dari input\n- **Memory-hard**: Memerlukan memori yang signifikan, membuat serangan paralel menjadi mahal\n\n**Panduan parameter biaya:**\n- **Biaya 10**: ~10ms (minimum yang direkomendasikan untuk 2024)\n- **Biaya 12**: ~40ms (keseimbangan baik untuk sebagian besar aplikasi)\n- **Biaya 14**: ~160ms (aplikasi keamanan tinggi)\n- **Biaya 15+**: 300ms+ (keamanan maksimum, dapat mempengaruhi pengalaman pengguna)\n\n**Kasus penggunaan umum:**\n- **Aplikasi web**: Penyimpanan password akun pengguna\n- **Autentikasi API**: Mengamankan kunci API dan token\n- **Keamanan database**: Melindungi data kredensial sensitif\n- **Sistem perusahaan**: Sistem autentikasi karyawan\n- **Aplikasi mobile**: Penyimpanan password lokal\n\n**Mengapa memilih bcrypt daripada alternatif:**\n- **Teruji tempur**: Dekade penggunaan dunia nyata\n- **Standar industri**: Direkomendasikan oleh ahli keamanan dan framework\n- **Kepatuhan regulatori**: Memenuhi sebagian besar persyaratan kepatuhan keamanan\n- **Keseimbangan kinerja**: Trade-off keamanan vs kecepatan yang dapat dikonfigurasi\n- **Adopsi luas**: Didukung oleh framework utama (Django, Rails, Spring, dll.)\n\n**Praktik terbaik:**\n- Gunakan biaya 12 atau lebih tinggi untuk aplikasi baru\n- Tinjau secara teratur dan tingkatkan biaya seiring peningkatan hardware\n- Jangan pernah menyimpan password teks biasa\n- Gunakan bcrypt untuk password, bukan untuk hashing tujuan umum\n- Implementasikan penanganan error yang tepat untuk mencegah serangan timing\n\n**Catatan keamanan:**\n⚠️ **Penting**: Meskipun bcrypt sangat baik untuk password, tidak cocok untuk hashing kriptografi tujuan umum. Untuk integritas file, tanda tangan digital, atau penggunaan non-password lainnya, pertimbangkan SHA-256, SHA-3, atau fungsi hash kriptografi lainnya."
  },
  "he": {
    "what-is-bcrypt": "מה זה bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt הוא פונקציית האש לסיסמאות שתוכננה על ידי Niels Provos ו-David Mazières ב-1999, המבוססת על הצופן Blowfish. הוא תוכנן במיוחד לביצוע האש בטוח של סיסמאות ונחשב באופן נרחב לאחת מהשיטות הטובות ביותר לאחסון סיסמאות.\n\n**מאפיינים עיקריים:**\n- **האש מתאים**: משתמש בפרמטר עלות (גורם עבודה) שהופך אותו לאטי יותר ובטוח יותר לאורך זמן\n- **שילוב מלח**: מייצר אוטומטית ומשלב מלח אקראי למניעת התקפות טבלת קשת\n- **בטיחות מוכחת בזמן**: למעלה מ-20 שנה של שימוש נרחב ללא התקפות מעשיות ידועות\n- **קושי ניתן לתצורה**: פרמטר העלות יכול להיות מותאם לשמירה על בטיחות ככל שהחומרה משתפרת\n- **רב-פלטפורמה**: זמין כמעט בכל שפת תכנות ופלטפורמה\n\n**איך bcrypt עובד:**\n🔧 **סקירת התהליך**:\n1. **יצירת מלח**: יוצר מלח אקראי של 128 ביט\n2. **הרחבת מפתח**: משתמש בסיסמה ובמלח להרחבת לוח הזמנים של מפתחות Blowfish\n3. **האש איטרטיבי**: מיישם שוב ושוב הצפנת Blowfish עם פרמטר העלות הקובע איטרציות\n4. **פורמט פלט**: מייצר מחרוזת סטנדרטית המכילה גרסה, עלות, מלח והאש\n\n**פורמט האש bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ האש של 31 תווים (22 תווי base64 + 9 תווים)\n│ │  └─ מלח של 22 תווים (מקודד base64)\n│ └─ פרמטר עלות (4-31, גבוה יותר = איטי יותר/בטוח יותר)\n└─ זיהוי גרסה ($2a$, $2b$, $2x$, $2y$)\n```\n\n**יתרונות בטיחות:**\n✅ **הגנת סיסמאות מעולה**:\n- **איטי לפי עיצוב**: יקר בכוונה מבחינה חישובית כדי לסכל התקפות brute force\n- **מלח מונע טבלאות קשת**: כל סיסמה מקבלת מלח ייחודי\n- **עמיד לעתיד**: העלות יכולה להיות מוגברת ככל שהחומרה הופכת מהירה יותר\n- **עמיד להתקפות זמן**: זמן ביצוע עקבי ללא קשר לקלט\n- **קשה לזיכרון**: דורש זיכרון משמעותי, הופך התקפות מקבילות ליקרות\n\n**מדריך פרמטרי עלות:**\n- **עלות 10**: ~10ms (מינימום מומלץ לשנת 2024)\n- **עלות 12**: ~40ms (איזון טוב לרוב היישומים)\n- **עלות 14**: ~160ms (יישומי אבטחה גבוהה)\n- **עלות 15+**: 300ms+ (אבטחה מקסימלית, עלול להשפיע על חוויית המשתמש)\n\n**מקרי שימוש נפוצים:**\n- **יישומי אינטרנט**: אחסון סיסמאות חשבונות משתמשים\n- **אימות API**: אבטחת מפתחות API וטוקנים\n- **אבטחת מסד נתונים**: הגנה על נתוני אישורים רגישים\n- **מערכות ארגוניות**: מערכות אימות עובדים\n- **יישומים ניידים**: אחסון סיסמאות מקומי\n\n**למה לבחור ב-bcrypt על פני חלופות:**\n- **נבדק בקרב**: עשרות שנים של שימוש בעולם האמיתי\n- **תקן תעשייתי**: מומלץ על ידי מומחי אבטחה ומסגרות עבודה\n- **ציות רגולטורי**: עונה על רוב דרישות הציות לאבטחה\n- **איזון ביצועים**: חילופין ניתנים לתצורה בין אבטחה לבין מהירות\n- **אימוץ נרחב**: נתמך על ידי מסגרות עבודה עיקריות (Django, Rails, Spring, וכו')\n\n**שיטות עבודה מומלצות:**\n- השתמש בעלות 12 או יותר ליישומים חדשים\n- בדוק באופן קבוע והגבר את העלות ככל שהחומרה משתפרת\n- לעולם אל תאחסן סיסמאות טקסט רגיל\n- השתמש ב-bcrypt לסיסמאות, לא לצרכי האש כלליים\n- יישם טיפול בשגיאות מתאים למניעת התקפות זמן\n\n**הערת בטיחות:**\n⚠️ **חשוב**: בעוד שbcrypt מעולה לסיסמאות, הוא לא מתאים לאש קריפטוגרפי כללי. לשלמות קבצים, חתימות דיגיטליות או שימושים אחרים שלא בסיסמאות, שקול SHA-256, SHA-3 או פונקציות האש קריפטוגרפיות אחרות."
  },
  "ms": {
    "what-is-bcrypt": "Apakah bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt adalah fungsi hash kata laluan yang direka oleh Niels Provos dan David Mazières pada 1999, berdasarkan cipher Blowfish. Ia direka khusus untuk hash kata laluan dengan selamat dan dianggap secara meluas sebagai salah satu amalan terbaik untuk penyimpanan kata laluan.\n\n**Ciri-ciri utama:**\n- **Hash adaptif**: Menggunakan parameter kos (faktor kerja) yang menjadikannya lebih perlahan dan selamat dari masa ke masa\n- **Integrasi garam**: Secara automatik menjana dan menggabungkan garam rawak untuk mencegah serangan jadual pelangi\n- **Keselamatan teruji masa**: Lebih 20 tahun penggunaan meluas tanpa serangan praktikal yang diketahui\n- **Kesukaran boleh konfigurasi**: Parameter kos boleh diselaraskan untuk mengekalkan keselamatan apabila perkakasan bertambah baik\n- **Merentas platform**: Tersedia dalam hampir setiap bahasa pengaturcaraan dan platform\n\n**Bagaimana bcrypt berfungsi:**\n🔧 **Gambaran keseluruhan proses**:\n1. **Penjanaan garam**: Mencipta garam rawak 128-bit\n2. **Pengembangan kunci**: Menggunakan kata laluan dan garam untuk mengembangkan jadual kunci Blowfish\n3. **Hash berulang**: Berulang kali menggunakan penyulitan Blowfish dengan parameter kos menentukan iterasi\n4. **Format output**: Menghasilkan rentetan piawai yang mengandungi versi, kos, garam dan hash\n\n**Format hash bcrypt:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ Hash 31 aksara (22 aksara base64 + 9 aksara)\n│ │  └─ Garam 22 aksara (dikodkan base64)\n│ └─ Parameter kos (4-31, lebih tinggi = lebih perlahan/lebih selamat)\n└─ Pengecam versi ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Kelebihan keselamatan:**\n✅ **Perlindungan kata laluan unggul**:\n- **Perlahan mengikut reka bentuk**: Sengaja mahal dari segi pengiraan untuk menggagalkan serangan kekerasan kasar\n- **Garam menghalang jadual pelangi**: Setiap kata laluan mendapat garam unik\n- **Kalis masa depan**: Kos boleh ditingkatkan apabila perkakasan menjadi lebih pantas\n- **Tahan serangan masa**: Masa pelaksanaan konsisten tanpa mengira input\n- **Sukar ingatan**: Memerlukan ingatan yang ketara, menjadikan serangan selari mahal\n\n**Panduan parameter kos:**\n- **Kos 10**: ~10ms (minimum disyorkan untuk 2024)\n- **Kos 12**: ~40ms (imbangan baik untuk kebanyakan aplikasi)\n- **Kos 14**: ~160ms (aplikasi keselamatan tinggi)\n- **Kos 15+**: 300ms+ (keselamatan maksimum, mungkin memberi kesan kepada pengalaman pengguna)\n\n**Kes penggunaan biasa:**\n- **Aplikasi web**: Penyimpanan kata laluan akaun pengguna\n- **Pengesahan API**: Melindungi kunci API dan token\n- **Keselamatan pangkalan data**: Melindungi data kelayakan sensitif\n- **Sistem perusahaan**: Sistem pengesahan pekerja\n- **Aplikasi mudah alih**: Penyimpanan kata laluan tempatan\n\n**Mengapa pilih bcrypt berbanding alternatif:**\n- **Teruji pertempuran**: Berdekad-dekad penggunaan dunia sebenar\n- **Piawaian industri**: Disyorkan oleh pakar keselamatan dan rangka kerja\n- **Pematuhan peraturan**: Memenuhi kebanyakan keperluan pematuhan keselamatan\n- **Imbangan prestasi**: Pertukaran keselamatan vs kelajuan boleh konfigurasi\n- **Penggunaan meluas**: Disokong oleh rangka kerja utama (Django, Rails, Spring, dll.)\n\n**Amalan terbaik:**\n- Gunakan kos 12 atau lebih tinggi untuk aplikasi baharu\n- Semak secara berkala dan tingkatkan kos apabila perkakasan bertambah baik\n- Jangan sekali-kali simpan kata laluan teks biasa\n- Gunakan bcrypt untuk kata laluan, bukan untuk hash tujuan umum\n- Laksanakan pengendalian ralat yang sesuai untuk mencegah serangan masa\n\n**Nota keselamatan:**\n⚠️ **Penting**: Walaupun bcrypt sangat baik untuk kata laluan, ia tidak sesuai untuk hash kriptografi tujuan umum. Untuk integriti fail, tandatangan digital atau kegunaan bukan kata laluan lain, pertimbangkan SHA-256, SHA-3 atau fungsi hash kriptografi lain."
  },
  "no": {
    "what-is-bcrypt": "Hva er bcrypt?",
    "what-is-bcrypt-description-markdown": "bcrypt er en passord-hash-funksjon designet av Niels Provos og David Mazières i 1999, basert på Blowfish-chifferet. Den er spesielt designet for sikker hashing av passord og anses bredt som en av de beste praksisene for passordlagring.\n\n**Nøkkelegenskaper:**\n- **Adaptiv hashing**: Bruker en kostparameter (arbeidsfaktor) som gjør den tregere og sikrere over tid\n- **Salt-integrasjon**: Genererer automatisk og inkorporerer et tilfeldig salt for å forhindre regnbuetabell-angrep\n- **Tidstestet sikkerhet**: Over 20 år med utbredt bruk uten kjente praktiske angrep\n- **Konfigurerbar vanskelighet**: Kostparameteren kan justeres for å opprettholde sikkerhet etter hvert som maskinvare forbedres\n- **Kryssplattform**: Tilgjengelig i praktisk talt alle programmeringsspråk og plattformer\n\n**Hvordan bcrypt fungerer:**\n🔧 **Prosessoversikt**:\n1. **Salt-generering**: Oppretter et tilfeldig 128-bits salt\n2. **Nøkkelutvidelse**: Bruker passord og salt for å utvide Blowfish-nøkkelplanen\n3. **Iterativ hashing**: Anvender gjentatte ganger Blowfish-kryptering med kostparameteren som bestemmer iterasjoner\n4. **Utdataformat**: Produserer en standardisert streng som inneholder versjon, kostnad, salt og hash\n\n**bcrypt hash-format:**\n```\n$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW\n│ │  │  │                                                  \n│ │  │  └─ 31-tegns hash (22 tegn base64 + 9 tegn)\n│ │  └─ 22-tegns salt (base64-kodet)\n│ └─ Kostparameter (4-31, høyere = tregere/sikrere)\n└─ Versjonsidentifikator ($2a$, $2b$, $2x$, $2y$)\n```\n\n**Sikkerhetsfordeler:**\n✅ **Overlegen passordbeskyttelse**:\n- **Treg ved design**: Bevisst beregningsmessig dyr for å motvirke brute force-angrep\n- **Salt forhindrer regnbuetabeller**: Hvert passord får et unikt salt\n- **Fremtidssikker**: Kostnad kan økes etter hvert som maskinvare blir raskere\n- **Timing attack-resistent**: Konsekvent utførelsestid uavhengig av inndata\n- **Minnekrevende**: Krever betydelig minne, gjør parallelle angrep dyre\n\n**Kostparameter-veiledning:**\n- **Kostnad 10**: ~10ms (anbefalt minimum for 2024)\n- **Kostnad 12**: ~40ms (god balanse for de fleste applikasjoner)\n- **Kostnad 14**: ~160ms (høysikkerhetsapplikasjoner)\n- **Kostnad 15+**: 300ms+ (maksimal sikkerhet, kan påvirke brukeropplevelse)\n\n**Vanlige brukstilfeller:**\n- **Webapplikasjoner**: Lagring av brukerkontopassord\n- **API-autentisering**: Sikring av API-nøkler og tokens\n- **Databasesikkerhet**: Beskyttelse av sensitive legitimasjonsdata\n- **Bedriftssystemer**: Ansatt-autentiseringssystemer\n- **Mobilapplikasjoner**: Lokal passordlagring\n\n**Hvorfor velge bcrypt fremfor alternativer:**\n- **Kampprøvd**: Tiår med bruk i den virkelige verden\n- **Industristandard**: Anbefalt av sikkerhetseksperter og rammeverk\n- **Regulatorisk overholdelse**: Oppfyller de fleste sikkerhetskrav\n- **Ytelsesbalanse**: Konfigurerbar sikkerhet vs hastighet-avveining\n- **Bred adopsjon**: Støttet av store rammeverk (Django, Rails, Spring, etc.)\n\n**Beste praksis:**\n- Bruk kostnad 12 eller høyere for nye applikasjoner\n- Gjennomgå regelmessig og øk kostnad etter hvert som maskinvare forbedres\n- Lagre aldri passord i klartekst\n- Bruk bcrypt for passord, ikke for generell hashing\n- Implementer riktig feilhåndtering for å forhindre timing-angrep\n\n**Sikkerhetsnotat:**\n⚠️ **Viktig**: Selv om bcrypt er utmerket for passord, er det ikke egnet for generell kryptografisk hashing. For filintegritet, digitale signaturer eller andre ikke-passord-bruk, vurder SHA-256, SHA-3 eller andre kryptografiske hash-funksjoner."
  }
}
</i18n>
